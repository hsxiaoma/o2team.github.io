{"title":"Aotu.io","description":"凹凸实验室(Aotu.io) 始建于2015年，是一个年轻基情的技术社区组织。<br/>O2面向多终端技术体系，致力于构建沉淀与分享包括但不限于交互、页面制作技巧、前端开发、原生APP开发等方面的专业知识及案例。","language":"zh-cn","link":"https://aotu.io","pubDate":"Mon, 25 Jun 2018 04:53:41 GMT","lastBuildDate":"Fri, 06 Jul 2018 09:48:35 GMT","generator":"hexo-generator-json-feed","webMaster":"凹凸实验室","items":[{"title":"为何我们要用 React 来写小程序 - Taro 诞生记","link":"https://aotu.io/notes/2018/06/25/the-birth-of-taro/","description":"在互联网不断发展的今天，前端程序员们也不断面临着新的挑战，在这个变化多端、不断革新自己的领域，每一年都有新的美好事物在发生。从去年微信小程序的诞生，到今年的逐渐火热，以及异军突起的轻应用、百度小程序等的出现，前端可以延伸的领域已经越来越广，当然也意味着业务在不断扩大。这时候，如何通过技术手段来提升开发效率，应对不断增长的业务，就是一个值得探索的话题。本文将对 Taro 诞生的故事，进行深入浅出地介绍，记录下这个忙碌的春夏之交发生的故事。 让人又爱又恨的微信小程序自 2017-1-9 微信小程序（以下简称小程序）诞生以来，就伴随着赞誉与争议不断。从发布上线时的不被大多数人看好，到如今的逐渐火热，甚至说是如日中天也不为过，小程序用时间与实践证明了自己的价值。同时于开发者来说，小程序的生态不断在完善，许多的坑已被踩平，虽然还是存在一些令人诟病的问题，但已经足见微信的诚意了。这个时候要是还没有上手把玩过小程序，就显得非常OUT了。 小程序对于前端程序员来说应该算得上是福音了，用前端相关的技术，获得丝般顺滑的 Native 体验，前端们又可以在产品小姐姐面前硬气一把了。可以说小程序给前端程序员打开了一扇新的大门，大家都应该感谢微信，但是从开发的角度来说，小程序的开发体验就非常值得商榷了，不仅语法上显得有些不伦不类，而且有些莫名其妙的坑也经常让人不经意间感叹一下和谐社会，从市面上层出不穷的小程序开发框架就可见一斑。以下就盘点部分小程序开发的痛点。 代码组织与语法在小程序中，一个页面 page 可能拥有 page.js、page.wxss、page.wxml 、page.json 四个文件 这样在开发的时候就需要来回进行文件切换，尤其是在同时开发模板和逻辑的时候，切来切去会显得尤其麻烦，影响开发效率，但小程序原生只支持这么写，就显得比较尴尬了。 而在语法上，小程序的语法可以说既像 React ，又像 Vue，不能说显得有点不伦不类吧，但在使用上总是感觉有些别扭，对于开发者来说，等于又要学习一套新的语法，提升了学习成本。而且，小程序的模板由于没有编辑器插件的支持，书写的时候也没有智能提示与 lint 检查，书写起来显得有些麻烦。 命名规范在小程序中到处可见规范不统一的情况 例如组件的属性，以最简单的 &lt;button /&gt; 组件为例，在小程序官方文档中，该组件的属性部分截图如下，大家可以感受下 &lt;button /&gt; 组件属性名既有以中划线分割多个单词的情况 session-form，也有多个单词连写的情况 bindgetphonenumber。当然这也不是最严重的，你可以说事件绑定的规范就是 bind + 事件名 ，而其他属性的规范就是中划线分割单词，我一度以为小程序就是这个作为标准，直到我看到了 &lt;progress /&gt; 组件 这和说好的不一样啊喂！ 同样的情况也出现在 页面 与 组件 的生命周期方法中，页面 的生命周期方法有 onLoad、onReady、onUnload 等，但到了 组件 中则是 created、attached 、ready 等，这样规范又不统一了，为啥 页面 的生命周期方法是 on+Xxx 的格式，但到了 组件 里缺不一样了呢，有点费解。 开发方式小程序官方提供了 微信开发工具 作为开发编译工具，而对于代码本身没有提供一个类似 webpack 的工程化开发工具，来解决开发中的一些问题，所以小程序原生的开发方式显得不那么现代化，这也是很多小程序开发框架致力于解决的问题。例如，在小程序开发中 不能使用 npm 管理依赖，在小程序中需要手动把第三方代码文件下载到本地，然后再 reuqire 进行使用，显得不那么优雅 不能使用 Sass 等 CSS 预处理器，由于没有预编译的概念，小程序开发中无法使用市面上流行的 CSS 预处理器，这样会使得样式代码难以管理 不完整的 ES Next 语法支持，小程序默认只能支持极少一部分 ES6 规范的语法，而 ES 是不断往前发展的，一些非常优秀的新语法特性就不能使用了 手动的文件处理，像图片压缩、代码压缩等等的一些文件操作，必须手工来处理，显得有些繁琐 以上就是从开发者的角度看到的一些小程序的开发问题，不过纵然有千般困难，我们总要面对，作为新时代的前端开发工程师，我们不能一味忍受问题，要保持技术的头脑，以技术作为武器，用技术手段去提升的我们开发体验。 突发奇想：我能不能用React来写小程序目前前端界言及前端框架，必离不开依然保持着统治地位的 React 与 Vue，这两个都是非常优秀的前端 UI 框架，而且在网上也经常能看到两个框架的粉丝之间热情交流，碰撞出一些思想火花，显得社区异常活跃。 而我们团队也在去年勇敢地抛弃了历史包袱，非常荣幸地引入了 React 开发方式，让我们团队丢掉了煤油灯，开始通上了电。而且也研发出了一款优秀的类 React 框架 Nerv ，让我们和 React 开发思想结合得更深。 与小程序的开发方式相比，React 明显显得更加现代化、规范化，而且 React 天生组件化更适合我们的业务开发，JSX 也比字符串模板有更强的表现力。那么这时候我们就在思考，我们能不能用 React 来写小程序？ 理性地探索类比通过对比体验 小程序和 React ，我们还是能发现两者之间相似的地方 生命周期小程序的生命周期和 React 的生命周期，在很大程度上是类似的，我们甚至能找到他们之间的对应关系 app 及页面的生命周期 小程序 React onLaunch componentWillMount onLoad componentWillMount onReady componentDidMount onShow 不支持，需要特殊处理 onHide 不支持，需要特殊处理 onUnload componentWillUnmount 可以看出，对于 app 及 页面 来说，除了 onShow 与 onHide 两个方法，其他方法都能在 React 中找到对应。 数据更新方式在 React 中，组件的内部数据是用 state 来进行管理的，而在小程序中组件的内部数据都是用 data 来进行管理，两者具有一定相似性。而同时在 React 中，我们更新数据使用的是 setState 方法，传入新的数据或者生成新数据的函数，从而更新相应视图。在小程序中，则对应的有 setData 方法，传入新的数据，从而更新视图。 两者都是以数据驱动视图的方式进行更新，而且 api 神似。 事件绑定小程序中绑定事件使用的是 bind + 事件名 的方式，例如点击事件，小程序中是 bindtap 1&lt;view bindtap=\"handlClick\"&gt;1&lt;/view&gt; 而在 React 里，则是 on + 事件名 的方式，例如点击事件， React web 中是 onClick 1&lt;View onClick=&#123;this.handlClick&#125;&gt;1&lt;/View&gt; 虽然看上去不一样，但其实是可以类比的，我们只需要在编译时将 on + 事件名 的形式编译成 bind + 事件名 的形式就可以了。 如此看来，两者之间有些相似，用 React 来写小程序貌似是可行的，但接下来我们就发现了巨大的差异。 巨大的差异React 与小程序之间最大的差异就是他们的模板了，在 React 中，是使用 JSX 来作为组件的模板的，而小程序则与 Vue 一样，是使用字符串模板的。这样两者之间就有着巨大的差异了。 JSX 12345678910render () &#123; return ( &lt;View className='index'&gt; &#123;this.state.list.map((item, idx) =&gt; ( &lt;View key=&#123;idx&#125;&gt;&#123;item&#125;&lt;/View&gt; ))&#125; &lt;Button onClick=&#123;this.goto&#125;&gt;走你&lt;/Button&gt; &lt;/View&gt; )&#125; 小程序模板 1234&lt;view class=\"index\"&gt; &lt;view wx:key=&#123;idx&#125; wx:for=\"&#123;&#123;list&#125;&#125;\" wx:for-item=\"item\" wx:for-index=\"idx\"&gt;&#123;&#123;item&#125;&#125;&lt;/view&gt; &lt;view bindtap=\"goto\"&gt;走你&lt;/view&gt;&lt;/view&gt; 众所周知，JSX 其实本质上就是 JS，我们可以在里面写任意的逻辑代码，这样一来就比字符串模板的表现力与操作性要强多了，况且，小程序的字符串模板功能比较羸弱，只有一些比较基本的功能。那这样的话，要如何来实现用 JSX 来写小程序模板呢。 编译原理的力量我们可以仔细来分析我们的需求，我们期望使用 JSX 来书写小程序模板，但小程序显然是不支持执行 JSX 代码的（要是支持的话，Taro 应该也就不存在了吧），我们也不能期望微信能给我们开个后门来跑 JSX。那么这个时候我们就想，我们要是能够将 JSX 编译成小程序模板就好了。 事实上在我们平时的开发中，这种编译的操作到处可见，babel 就是我们最常用的 JS 代码编译器，一般浏览器是不能支持一些非常新的语法特性的，但我们又想使用它们，这个时候就可以借助 babel 来将我们的高版本的 ES 代码，编译成浏览器可以运行的 ES 代码。而我们像要将 JSX编译成小程序模板，也是同样的道理。我们首先来了解一下 Babel 的运行机制。 Babel 作为一个 代码编译器 ，能够将 ES6/7/8 的代码编译成 ES5 的代码，其核心利用的就是计算中非常基础的编译原理知识，将输入语言代码，通过编译器执行，输出目标语言的代码。编译原理的一般过程就是，输入源程序，经过词法分析、语法分析，构造出语法树，再经过语义分析，理解程序正确与否，再对语法树做出需要的操作与优化，最终生成目标代码。 Babel 的编译过程亦是如此，主要包含三个阶段 解析过程，在这个过程中进行词法、语法分析，以及语义分析，生成符合 ESTree 标准 虚拟语法树(AST) 转换过程，针对 AST 做出已定义好的操作，babel 的配置文件 .babelrc 中定义的 preset 、 plugin 就是在这一步中执行并改变 AST 的 生成过程，将前一步转换好的 AST 生成目标代码的字符串 为了更好地理解这些过程，大家可以利用 Ast Explorer 这个网站接一下自己的代码，感受一下每一部分代码所对应的 AST 结构。 可以看到，一份源码经过编译器解析后，会变成类似如下的结构 1234567891011121314&#123; type: \"Program\", start: 0, end: 78, loc: &#123; start, end &#125; sourceType: \"module\", body: [ &#123; type: \"VariableDeclaration\", ... &#125;, &#123; type: \"VariableDeclaration\", ... &#125;, &#123; type: \"FunctionDeclaration\", ... &#125;, &#123; type: \"ExpressionStatement\", ... &#125; ] ...&#125; 其中，body 里包含的就是我们示例代码的语法树结构，第一个 VariableDeclaration 对应的是 const a = 1，第三个 FunctionDeclaration 对应的则是 function sum (a, b) { }，分别就是 JS 中的变量定义与函数定义，每一个树节点里都会包含许多子节点，这样就形成了一个树形结构，更多的节点类型，请参考 babel types。 当然我们在这儿只是简单介绍下编译原理与 babel，编译原理是一门非常深奥的课程， babel 也是一个非常优秀的工具，希望在后续的文章中能和大家再详细探讨这一部分内容。 再次回到我们的需求，将 JSX 编译成小程序模板，非常幸运的是 babel 的核心编译器 babylon 是支持对 JSX 语法的解析的，我们可以直接利用它来帮我们构造 AST，而我们需要专注的核心就是如何对 AST 进行转换操作，得出我们需要的新 AST，再将新 AST 进行递归遍历，生成小程序的模板。 JSX 代码 123456789&lt;View className='index'&gt; &lt;Button className='add_btn' onClick=&#123;this.props.add&#125;&gt;+&lt;/Button&gt; &lt;Button className='dec_btn' onClick=&#123;this.props.dec&#125;&gt;-&lt;/Button&gt; &lt;Button className='dec_btn' onClick=&#123;this.props.asyncAdd&#125;&gt;async&lt;/Button&gt; &lt;View&gt;&#123;this.props.counter.num&#125;&lt;/View&gt; &lt;A /&gt; &lt;Button onClick=&#123;this.goto&#125;&gt;走你&lt;/Button&gt; &lt;Image src=&#123;sd&#125; /&gt;&lt;/View&gt; 编译生成小程序模板 123456789101112&lt;import src=\"../../components/A/A.wxml\" /&gt;&lt;block&gt; &lt;view class=\"index\"&gt; &lt;button class=\"add_btn\" bindtap=\"add\"&gt;+&lt;/button&gt; &lt;button class=\"dec_btn\" bindtap=\"dec\"&gt;-&lt;/button&gt; &lt;button class=\"dec_btn\" bindtap=\"asyncAdd\"&gt;async&lt;/button&gt; &lt;view&gt;&#123;&#123;counter.num&#125;&#125;&lt;/view&gt; &lt;template is=\"A\" data=\"&#123;&#123;...$$A&#125;&#125;\"&gt;&lt;/template&gt; &lt;button bindtap=\"goto\"&gt;走你&lt;/button&gt; &lt;image src=\"&#123;&#123;sd&#125;&#125;\" /&gt; &lt;/view&gt;&lt;/block&gt; 这时候，聪明的你应该就能发现问题的难点所在了，要知道小程序的模板只是字符串，而 JSX 则是真正的 JS 代码扩展，其语法之丰富，显然不是字符串模板所能比，在这一步中，我们要做的操作，包括但不仅限于如下 理解三目运算符与逻辑表达式，例如三目运算符 abc ? : &lt;View&gt;1&lt;/View&gt; : &lt;View&gt;2&lt;/View&gt; 需要编译成 &lt;view wx:if=&quot;&quot;&gt;1&lt;/view&gt;&lt;view wx:else&gt;2&lt;/view&gt; 理解数组 map 语法，例如 map 的使用 abc.map(item =&gt; &lt;View&gt;item&lt;/View&gt;) 需要编译成 &lt;view wx:for=&quot;&quot; wx:for-item=&quot;item&quot;&gt;item&lt;/view&gt; 等等 以上仅仅是我们转换规则的冰山一角，JSX 的写法极其灵活多变，我们只能通过穷举的方式，将常用的、React 官方推荐的写法作为转换规则加以支持，而一些比较生僻的，或者是不那么推荐的写的写法则不做支持，转而以 eslint 插件的方式，提示用户进行修改。目前我们支持的 JSX 转换规则，大致能覆盖到 JSX 80% 的写法操作。 关于 JSX 转小程序模板这一部分，我们将在后续的技术原理分析系列文章中，详细为大家介绍。 还能不能干点别的经过我们一次次的探索，以及一波波猛如虎的操作，我们已经可以将类 React 代码转成小程序可以跑的代码了，也就是说我们已经可以正式以 React 的方式来写小程序的代码了。喜大普奔！但是我们激动之余，冷静下来继续思考，我们还能不能干点别的有意思的事情呢。 分析一下需求我们发现，在平常的工作中，我们业务通常有一些多端的需求，就是要求小程序要有，H5 要有，甚至 RN 也能有就最好了，我猜产品经理还看不上快应用，不然肯定要求我们快应用也上一套吧，反正你们不是经常号称代码优秀、高度可复用么。这个时候，你就会发现，差不多的界面和逻辑，你可能需要重复写上好几轮，这时候要是有个多端代码生成工具就好了，只写一份代码，可以多端运行。Write once, run anywhere，相信是所有工程师的梦想。 依然编译原理的力量这时候我们回忆一下前文的内容，将一份代码编译成多端代码，这不正是编译原理干的事么，我们可以输入一份源代码，针对不同的端设定好对应的转换规则，再一键转换出对应端的代码。而且由于我们已经遵循 React 语法了，那我们再转成 H5 端（使用 Nerv）与 RN 端（使用 React）也就有了天然的优势。 设计思路补完但是仔细思考我们又会发现，仅仅将代码按照对应语法规则转换过去后，还远远不够，因为不同端会有自己的原生组件，端能力 API 等等，代码直接转换过去后，可能不能直接执行。例如，小程序中普通的容器组件用的是 &lt;view /&gt;，而在 H5 中则是 &lt;div /&gt;；小程序中提供了丰富的端能力 API，例如网络请求、文件下载、数据缓存等，而在 H5 中对应功能的 API 则不一致。 所以，为了弥补不同端的差异，我们需要订制好一个统一的组件库标准，以及统一的 API 标准，在不同的端依靠它们的语法与能力去实现这个组件库与 API，同时还要为不同的端编写相应的运行时框架，负责初始化等等操作。通过以上这些操作，我们就能实现一份一键生成多端的需求了。在 Taro 最初的设计中，我们组件库与 API 的标准就是源自小程序的，因为我们觉得既然已经有定义好的组件库与 API 标准，那为啥不直接拿来使用呢，这样不仅省去了定制标准的冥思苦想，同时也省去了为小程序开发组件库与 API 的麻烦，只需要让其他端来向小程序靠齐就好。 可能有些人会有疑问，既然是为不同的端实现了对应的组件库与端能力 API （小程序除外，因为组件库和 API 的标准都是源自小程序），那么是怎么能够只写一份代码就够了呢？因为我们有编译的操作，在书写代码的时候，只需要引入标准组件库 @tarojs/components 与运行时框架 @tarojs/taro ，代码经过编译之后，会变成对应端所需要的库。 既然组件库以及端能力都是依靠不同的端做不同实现来抹平差异，那么同样的，如果我们想为 Taro 引入更多的功能支持的话，有时候也需要按照这个套路来。例如，为了提升开发便利性，我们为 Taro 加入了 Redux 支持，我们的做法就是，在小程序端，我们实现了 @tarojs/redux 这个库来作为小程序的 Redux 辅助库，并且以他作为基准库，它具有和 react-redux 一致的 API，在书写代码的时候，引用的都是 @tarojs/redux ，经过编译后，在 H5 端会替换成 nerv-redux（Nerv的 Redux 辅助库），在 RN 端会替换成 react-redux。这样就实现了 Redux 在 Taro 中的多端支持。 以上就是 Taro 的整体设计思路，里面还有很多细节没有展开去阐述，可能大家会觉得有些意犹未尽，后续我们将会产出一系列的文章来阐述 Taro 的技术细节，例如 《Taro 开发工具原理分析》、《Taro 代码编译的背后》、《深入浅出 JSX 转小程序模板》等等。 最后的最后Taro 从立项之初到现在已经差不多有了三个月左右的时间，从最初的激烈讨论方案，各种思想的碰撞，到方案逐渐成型，进入火热的开发迭代，再到现在的小程序端和 H5 端顺利支持，从而决定走向开源。这一路走来，收获颇丰，既有跟团队小伙伴一起创造的激动，也有无数个日夜加班的苦思。Taro 是凹凸实验室的诚意之作，我们也将会一直维护下去，希望 Taro 能越来越好，帮助更多人创造更多价值。 项目官网：https://taro.aotu.io/ 项目 GitHub：https://github.com/NervJS/taro 同时，有任何关于 Taro 希望沟通交流的，欢迎~","pubDate":"Mon, 25 Jun 2018 04:53:41 GMT","guid":"https://aotu.io/notes/2018/06/25/the-birth-of-taro/","category":"小程序"},{"title":"多端统一开发框架 - Taro","link":"https://aotu.io/notes/2018/06/07/Taro/","description":"Taro - 多端开发框架Taro 是什么？Taro 是由凹凸实验室打造的一套遵循 React 语法规范的多端统一开发框架。 现如今市面上端的形态多种多样，Web、App 端(React Native)、微信小程序等各种端大行其道，当业务要求同时在不同的端都要求有所表现的时候，针对不同的端去编写多套代码的成本显然非常高，这时候只编写一套代码就能够适配到多端的能力就显得极为需要。 使用 Taro，我们可以只书写一套代码，再通过 Taro 的编译工具，将源代码分别编译出可以在不同端（微信小程序、H5、App 端等）运行的代码。同时 Taro 还提供开箱即用的语法检测和自动补全等功能，有效地提升了开发体验和开发效率。 Taro 能提供什么？一次编写，多端运行既然是一个多端解决方案，Taro 最重要的能力当然是写一套代码输出多端皆可运行的代码。目前 Taro 已经支持一套代码同时生成 H5 和小程序，App端(React Native)端也即将支持，同时诸如快应用等端也将得到支持。 同时 Taro 也已经投入到了生产环境使用，目前已经支撑了一个 3 万行代码小程序 TOPLIFE 的开发并上线。京东购物 小程序和 一起有局 小程序也在使用 Taro 部分重构中，即将上线。未来也将接入更多业务。 现代前端开发流程和微信自带的小程序框架不一样，Taro 积极拥抱社区现有的现代开发流程，包括但不限于： NPM 包管理系统 ES6+ 语法 自由的资源引用 CSS 预处理器和后处理器（SCSS、Less、PostCSS） 对于微信小程序的编译流程，我们从 Parcel 得到灵感，自研了一套打包机制将 AST 不断传递，因此代码分析的速度得到了很大的提高。一台 2015 年 的 15寸 RMBP 在编译上百个组件时仅需要大约 15 秒左右。 和 React 完全一致的 API 和组件化系统在 Taro 中，你不用像小程序一样区分什么是 App 组件，什么是 Page 组件，什么是 Component 组件，Taro 全都是 Component 组件，并且和 React 的生命周期完全一致。可以说，一旦你掌握了 React，那就几乎掌握了 Taro。而学习 React 的资源也几乎是汗牛充栋，完全不用担心学不会。 Taro 和 React 一样，同样使用声明式的 JSX 语法。相比起字符串的模板语法，JSX 在处理精细复杂需求的时候会更得心应手。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 一个典型的 Taro 组件import Taro, &#123; Component &#125; from '@tarojs/taro'import &#123; View, Button &#125; from '@tarojs/components'export default class Home extends Component &#123; constructor (props) &#123; super(props) this.state = &#123; title: '首页', list: [1, 2, 3] &#125; &#125; componentWillMount () &#123;&#125; componentDidMount () &#123;&#125; componentWillUpdate (nextProps, nextState) &#123;&#125; componentDidUpdate (prevProps, prevState) &#123;&#125; shouldComponentUpdate (nextProps, nextState) &#123; return true &#125; add = (e) =&gt; &#123; // dosth &#125; render () &#123; const &#123; list, title &#125; = this.state return ( &lt;View className='index'&gt; &lt;View className='title'&gt;&#123;title&#125;&lt;/View&gt; &lt;View className='content'&gt; &#123;list.map(item =&gt; &#123; return ( &lt;View className='item'&gt;&#123;item&#125;&lt;/View&gt; ) &#125;)&#125; &lt;Button className='add' onClick=&#123;this.add&#125;&gt;添加&lt;/Button&gt; &lt;/View&gt; &lt;/View&gt; ) &#125;&#125; 良好的开发效率和体验鉴于 Taro 的语法和 React 完全一样，因此编辑器/IDE 能够对 Taro 的支持和 React 是几乎一样的。现代的编辑器默认都对 JSX 进行了支持，如果没有，找一个插件也是非常容易的事情。但毕竟我们做 Taro 就是为了提升开发效率和开发体验，而真正使用 Taro 的人就是我们自己或正坐在我们旁边的同事。因此在此基础上，我们又对 Taro 开发体验进行了进一步加强。 自定义 ESLint 规则我们之前提到过，当学会了 React，其实也差不多会 Taro 了。其中很重要的一个原因就是我们对 Taro 不支持的语法和特性单独写了 ESLint 规则：开发者只管写代码，写到不支持的语法/特性编辑器会报错，并给出报错信息和一个文档地址描述。 类型安全和运行时检测JSX 的本质就是 JavaScript 的语法增强，所以例如没有 import 组件等语法错误在编译期就能发现。开发者也可以使用 TypeScript 或 Flow 来对代码的可靠性进一步增强，或使用 PropsType 在运行时进一步保障代码的鲁棒性。 高效的自动补全和 ES6+ 语法Taro 的所有 API（包括微信小程序等端能力接口）都有智能的提醒和自动补全，包括接口的参数和返回值。 Taro 的设计思路我们的初心就是做一款能够适配多端的解决方案，结合业务场景、技术选型和前端历史发展进程，我们的解决方案必须满足下述要求： 代码多端复用，不仅能运行在时下最热门的 H5、微信小程序、React Native，对其他可能会流行的端也留有余地和可能性。 完善和强大的组件化机制，这是开发复杂应用的基石。 与目前团队技术栈有机结合，有效提高效率。 学习成本足够低 背后的生态强大 同时满足这几个需求并不容易，在我们经过充分地调研和思考之后发现只有 React 体系能够满足我们的需求。而对于微信小程序而言，使用 React 完全没有办法进行开发——直到我们从 codemod 得到灵感： 在一个优秀且严格的规范限制下，从更高抽象的视角（语法树）来看，每个人写的代码都差不多。 也就是说，对于微信小程序这样不开放不开源的端，我们可以先把 React 代码分析成一颗抽象语法树，根据这颗树生成小程序支持的模板代码，再做一个小程序运行时框架处理事件和生命周期与小程序框架兼容，然后把业务代码跑在运行时框架就完成了小程序端的适配。 对于 React 已经支持的端，例如 Web、React Native 甚至未来的 React VR，我们只要包一层组件库再做些许样式支持即可。鉴于时下小程序的热度和我们团队本身的业务侧重程度，组件库的 API 是以小程序为标准，其他端的组件库的 API 都会和小程序端的组件保持一致。 技术选型与权衡在我们前面社区已经有多个优秀的框架以小程序为核心对多端适配进行了探索，我们将各个开发框架的主要特点和特性进行了对比并制成图表。大家可以结合团队技术栈、技术需求以及框架特点、特性进行选型和权衡。 结语经过数个月的开发，Taro 从第一次 commit 到发展成包括 16 个包，十多位同学共同参与的大型项目。与此同时，Taro 也在生产环境支撑了数个复杂业务线上项目的开发，将来也会支撑更多业务。 Taro 的技术方案和实现也根植于社区，我们也希望为技术社区的发展壮大贡献一份自己的力量。秉持着凹凸实验室长久以来开源、开放、共享的优良传统，我们今天将 Taro 全部代码开源，为广大开发者快速开发多端项目提供一整套技术解决方案。未来，我们也将继续拓展 Taro 现有能力，支持更多端能力，继续完善开发者体验，提高开发者效率，帮助更多开发者，同时也从社区中汲取养分，让 Taro 变得更加强大。 官网：http://taro.aotu.io/ GitHub: http://github.com/nervjs/taro 如果你还没听过 Nerv，可以来这里看看：https://nerv.aotu.io/","pubDate":"Thu, 07 Jun 2018 03:04:27 GMT","guid":"https://aotu.io/notes/2018/06/07/Taro/","category":"小程序"},{"title":"图像处理 - ImageMagick 简单介绍与案例","link":"https://aotu.io/notes/2018/06/06/ImageMagick_intro/","description":"在客户端我们可以用 PhotoShop 等 GUI 工具处理静态图片或者动态 GIF 图片，不过在服务器端对于 WEB 应用程序要处理图片格式转换，缩放裁剪，翻转扭曲，PDF解析等操作， GUI 软件就很难下手了，所以此处需要召唤命令行工具来帮我们完成这些事。 ImageMagick: 是一款创建、编辑、合成，转换图像的命令行工具。支持格式超过 200 种，包括常见的 PNG, JPEG, GIF, HEIC, TIFF, DPX, EXR, WebP, Postscript, PDF, SVG 等。功能包括调整，翻转，镜像(mirror)，旋转，扭曲，修剪和变换图像，调整图像颜色，应用各种特殊效果，或绘制文本，线条，多边形，椭圆和贝塞尔曲线等。 官网：https://www.imagemagick.org 下面放个小标识。 安装 ImageMagick 支持 Linux, Windows, Mac OS X, iOS, Android OS 等平台https://www.imagemagick.org/script/download.php 因为我是 MAC 机器，演示一下 brew 的安装方式咯1brew install imagemagick 基本命令与格式1、基本命令 ImageMagick 包括一组命令行工具来操作图片，安装好 ImageMagick 后，终端就可以使用如下命令了。 magick: 创建、编辑图像，转换图像格式，以及调整图像大小、模糊、裁切、除去杂点、抖动 ( dither )、绘图、翻转、合并、重新采样等。convert: 等同于 magick 命令。identify: 输出一个或多个图像文件的格式和特征信息，如分辨率、大小、尺寸、色彩空间等。mogrify: 与 magick 功能一样，不过不需要指定输出文件，自动覆盖原始图像文件。composite: 将一个图片或多个图片组合成新图片。montage: 组合多个独立的图像来创建合成图像。每个图像都可以用边框，透明度等特性进行装饰。 compare: 从数学和视觉角度比较源图像与重建图像之间的差异。display: 在任何 X server 上显示一个图像或图像序列。animate: 在任何 X server 上显示图像序列。import: 保存 X server 上的任何可见窗口并把它作为图像文件输出。可以捕捉单个窗口，整个屏幕或屏幕的任意矩形部分。conjure: 解释并执行 MSL ( Magick Scripting Language ) 写的脚本。stream: 一个轻量级工具，用于将图像或部分图像的一个或多个像素组件流式传输到存储设备。在处理大图像或原始像素组件时很有用。 2、命令格式基本命令的使用，遵循 Unix 风格的标准格式：1command [options] input_image output_image 比如我们将一张宽高 300x300 的图片 goods.png 转换成 200x200 的goods.jpg，可以这样用1convert -resize 200x200 goods.png goods.jpg -resize 定义图片尺寸，ImageMagick 所有的选项参数都在这个【命令行选项手册】。 但是随着功能的复杂，命令缓慢扩大成了这样的格式：1command [options] image1 [options] image2 [options] output_image 于是上面的命令也可以写成这样1convert goods.png -resize 200x200 goods.jpg 笔记：个人建议，如果转换的是一张图片，那么用第一种格式，因为像 -density 等一些选项必须放在 command 与 input_image 之间，所以为了省记都不写错，都写在 command 与 input_image 之间岂不很好。但是如果是多张图片转换，就需要按第二种格式，正确输出命令选项了。 提示：如果上面的工具命令在计算机上不可以使用，则可以把它们当作 magick 命令的子命令使用，例如1magick identify goods.png 3、指定文件格式默认情况下 ImageMagick 会读取图像中唯一标识格式的签名来确定文件格式，如果没有，则根据文件的扩展名来确定格式，如 image.jpg 被认为 jpeg 格式文件，如果都获取不到，则需要手动指定文件的格式。命令格式为 format:input_or_output_image。 输入文件一般情况应该不需要手动指定文件格式，输出文件的时候，png 格式分 png8、png24 等格式，如果 png8 格式的文件能够满足需求，指定合理的格式可以缩小文件的大小，示例如下。12convert goods.png png8:goods_8.pngconvert goods.png png24:goods_24.png 实际案例 文中案例基于 ImageMagick 7.0.7 1、生成缩略图需求：将一张宽高为 900x600 的图片 goods.jpg 生成宽高为 150x100 的缩略图 thumbnail.jpg 1convert -resize 150x100 -quality 70 -strip goods.jpg thumbnail.jpg 解释： -resize 150x100：定义输出的缩略图尺寸为 150x100。 -quality 70：降低缩略图的质量为 70，取值范围 1 ( 最低图像质量和最高压缩率 ) 到 100 ( 最高图像质量和最低压缩率 )，默认值根据输出格式有 75、92、100，选项适用于 JPEG / MIFF / PNG。 -strip：让缩略图移除图片内嵌的所有配置文件，注释等信息，以减小文件大小。 -resize 延伸解读，如下。 上面的例子中，输入的图片和输出的图片比例是一致的，所以不会有特殊情况出现，但是遇到比例不同的时候，上面的写法并不会得到 150x100 的图像，而是会根据图像的宽高比例，取最大值，得出来的结果可能是 150 宽和更小的高，或者 100 高和更小的宽；所以 IamgeMagick 提供了几种符号来定义缩放。123convert -resize '150x100!' goods.jpg thumbnail.jpgconvert -resize '150x100&gt;' goods.jpg thumbnail.jpgconvert -resize '150x100&lt;' goods.jpg thumbnail.jpg !：不管图片宽高如何，都缩放成 150x100 这样的尺寸。&gt;：只有宽高均大于 150x100 的图片才缩放成该尺寸 ( 按比例取最大值 )，小于的图片不做处理。&lt;：与 &gt; 功能相反。 提示：因为有些字符是 Linux shell 或其他系统的特殊字符，所以需要用引号包裹起来或者用反斜线 \\ 转义，另外，不同平台可能引号都是有差异的。 2、添加水印需求 ① ：给图片居中加上透明文本水印。 12convert -draw 'text 0,0 \"JD.COM\"' -fill 'rgba(221, 34, 17, 0.25)' -pointsize 36 \\-font 'cochin.ttc' -gravity center joy.jpg watermark.jpg 解释： -draw：绘图选项，text 声明绘制文本， 0,0 声明文本距离图片左上角的偏移值， JD.COM 声明绘制的文本，最好用引号包裹起来，避免输入特殊字符引起错误。绘制文本的格式为 text x,y string，当然还可以绘制其他类型，诸如圆 ( circle )、折线 ( polyline )。 -fill：对文本填充颜色，貌似 ImageMagick 命令中前面的选项是用来控制后面的选项的，所以应该把这样的修饰选项放到 -draw 前面比较好，很重要，后面的案例就是这样的。 -pointsize：指定文本的字体大小。 -font：指定字体。 -gravity：设置文本在图片里的排列方式 ( 类似 CSS 里的 align-items + justify-content )，center 表示水平垂直都居中，其他值还可以是：NorthWest, North, NorthEast, West, East, SouthWest, South, SouthEast，不记大小写。 \\：反斜线也是类 Unix 系统的续行字符，当一个命令很长时，我们可以把它写成多行，以便视觉上的美观和直观。 需求 ② ：给图片加上倾斜平铺透明文本水印。 1234convert -size 100x100 xc:none \\-fill '#d90f02' -pointsize 18 -font 'cochin.ttc' \\-gravity center -draw 'rotate -45 text 0,0 \"JD.COM\"' \\-resize 60% miff:- | composite -tile -dissolve 25 - joy.jpg watermark.jpg 解释：文本平铺水印其实是将文本画成一张 png 图片，然后用这张透明图片在目标图片上进行平铺。 -size：设置画布的大小。 xc:：全称 X Constant Image，是 canvas: 的别名，定义一张画布，用来绘图，常用格式为 xc:color，none 或者 transparent 设置画布为透明底，默认为白色。 -resize：该选项还可以指定百分比，意为缩放至原图像的百分之几。貌似 -pointsize 小于 14 后，-draw 里的 rotate 会不生效，所以用 -resize 来把平铺图案变得更小。 miff:-： miff: 声明输出 ImageMagick ( IM ) 自己的图像文件格式：MIFF，主要用途是以复杂的方式处理图像时当做中间保存格式，适用于从一个 IM 命令向另一个 IM 命令传递图像元数据和其他关联属性。 - 在管道符前面意为将 IM 命令执行的结果作为标准输出，在管道符后面则表示从标准输入中读取这个数据，如在管道符后面的 composite 中使用 - 读取刚刚生成的透明图像。 |：Linux shell 管道符，用于将上一个命令的标准输出传递到下一个命令作为标准输入。这里将生成的水印图案传递给 composite 命令。 -tile：顾名思义，让图案平铺。 -dissolve：设置平铺图案的透明度。 图释： 3、绘制验证码大概逻辑如下： 随机生成 4 个英文字母或数字。 创建一个宽高 100x40 的画布。 设置字体大小为 16，每个字符的宽高也就是 16 左右了，依次计算出每个字符的 x, y 坐标，再增加一丁点旋转。 随机创建一条透明曲线，加上噪点，增加图片被破解的难度（在保证肉眼能看得清楚的用户体验下）。 如果需要安全性更高的验证码，请了解验证码破解原理并做合理调整。 如果加上随机计算，可能代码会比较多，所以这里写成固定值，方便理解。 1234567891011convert 'xc:[100x40!]' -pointsize 20 -font 'cochin.ttc' \\-gravity NorthWest -strokewidth 1 \\-fill '#b72b36' -stroke '#b72b36' -draw 'translate 13,19 rotate 10 text -5,-8 \"5\"' \\-fill '#821d70' -stroke '#821d70' -draw 'translate 36,13 rotate -8 text -8,-8 \"C\"' \\-fill '#c7960a' -stroke '#c7960a' -draw 'translate 60,23 rotate 5 text -5,-8 \"2\"' \\-fill '#03610a' -stroke '#03610a' -draw 'translate 85,25 rotate 13 text -8,-8 \"E\"' \\-strokewidth 2 -stroke 'rgba(248, 100, 30, 0.5)' -fill 'rgba(0, 0, 0, 0)' \\-draw 'bezier -20,30 -16,10 20,2 50,20' \\-draw 'bezier 50,20 78,42 138,36 140,16' \\+noise Impulse \\captcha.jpg 结果： 鉴于字体比较细，可以用 strokewidth 加边框来加粗，或者使用字体的粗体版本，这里使用了第一种方式。 解释： xc:[100x40!]：设置画布大小的一种简写方式，方括号里写入画布宽高，注意要加 !，否则会出乎意料哟。 文本定位与旋转 画布宽 100px，平均分成 4 分，每份 25px, 文字宽 16px, 得文字 x 的坐标左右摆动范围为 +0px, +9px，y 坐标同理，用于设置 translate 值。 实际上字体本身并没有填充满整个 16x16 的区域，根据字体的不同，填满的区域可能各有不同，所以根据cochin 字体的特性，上面稍微将字体大小调整为 20，实际渲染出来的字母才是 16x16 左右大小，数字大概是 10x16，所以设置数字的 x,y 为 -5,-8，结合下面两个属性解释 x,y 的计算方式。 translate: 设置文本的横纵向偏移值。 rotate：设置文本旋转，单位 degrees。根据 gravity 的设置坐标系统有一丁点变化，所以请设置为 西北(NorthWest) ，表示以画布 0,0 坐标旋转，跟 HTML 5 Canvas 坐标系统一致。 根据这样的坐标系统，如果要文字按自身的中心旋转，得配合 translate 和 text 的 x,y 一起使用，原理可参考这篇文章[图像旋转的实现]，注意 translate 与 rotate 的顺序。 strokewidth：设置文本的边框宽度或线条宽度。 stroke：设置文本的边框颜色或线条颜色。 -fill &#39;rgba(0, 0, 0, 0)&#39;：上面设置了文本的填充颜色，会影响下面的贝塞尔曲线，所以这里指定一个透明的填充色以覆盖上面的设定，使曲线没有填充。 bezier：绘制贝塞尔曲线，一两句话我怕解释不清楚，所以请大家参考一下维基百科的解释或者这篇中文文章的解释，最后再参考一下 IM 官方示例的描述。上面两条三次贝塞尔曲线的坐标分别表示 起始点，起始点的控制点，结束点的控制点，结束点。 +noise：增加噪点，可以使用 convert -list noise 查看当前系统支持哪些算法的噪点，大概有 Gaussian, Impulse, Laplacian, Multiplicative, Poisson, Random, Uniform。 4、克隆及拼合图像 这个案例主要了解几个基本操作的 API。 12345convert \\\\( -crop 300x300+10+25 joy.jpg \\) \\\\( -resize 400x400 -crop 300x300+50+0 logo: \\) -swap 0,1 +append \\\\( -clone 0 -flop -flip \\) -append \\-resize 200x200 combined.jpg 结果如下： 解释： 圆括号 \\( ... \\)：图像堆栈 ( image stack )，相当于创建了一个独立作用域处理图像，这个可以使图像之前的处理互不干扰。圆括号需用反斜杠转义，才能不被 Shell 当做特殊字符处理，并且每个圆括号两边需要用空格隔开。不必要的圆括号会使 IM 增加少许额外的工作，但是却让命令更清晰不容易出错。 -crop：裁剪出图像的一个或多个矩形区域，格式为 {size}{+-}x{+-}y，如果不指定偏移值 x,y，则会被解释为按指定宽高切割图像成多少份（多图像）。 logo:：IM 内置图像，这个就是上图中拿着魔法棒的主人公了，本身宽高 640x480，其他内置图像还有：rose:，granite:等，看这里。 -swap： 交换图像的位置，格式 -swap index,index。 IM 在图像处理操作时，实际上很可能是在处理一个图像列表，当新图像被读入或者创建时，IM 会将该新图像添加到当前图像列表的末尾。 如上，本来我们的图像列表里有 2 张图，第一张是 joy，但是 -swap 0,1 的意思是交换第一张图与第二张图的位置，所以 joy 变成跑到后面了。 +append：水平连接当前图像列表的图像来创建单个较长的图像。 -append：垂直连接当前图像列表的图像来创建单个较长的图像。 -clone：克隆图像，格式为 -clone {index_range_list}。 -clone 0：表示克隆图像列表里的第一张图像。 -clone 1-2：表示克隆图像列表里的第二张到第三张图像。 -clone 0--1：0 表示第一张图像，-1 表示最后一张图像，所以整句命令则表示克隆整个图像列表。 -clone 2,0,1：表示克隆第三张，第一张，第二张图像，顺序根据指定的索引决定，用逗号分隔。 -flop：将图像水平翻转。 -flip：将图像垂直翻转。 笔记： 选项之间的顺序很重要。 与 -clone 雷同的选项还有诸如：-delete, -insert, -reverse, -duplicate，用于操作图像列表，功能与单词意思相同。 5、GIF 与图片互转5.1、GIF 转图片1convert -coalesce rain.gif frame.jpg -coalesce：根据图像 -dispose 元数据的设置覆盖图像序列中的每个图像，以重现动画序列中每个点的动画效果。下面用一张结果对比图来解释这句话。 原始图 ( rain.gif ) ： 结果对比： 5.2、定义输出文件名上面默认输出的文件名为：frame-0.jpg, frame-1.jpg, frame-2.jpg ...，如果想使用下划线作为符号，输出为 frame_0.jpg, frame_1.jpg, frame_2.jpg ...，则可以如下设置。 1convert -coalesce rain.gif frame_%d.jpg 或者 1convert -coalesce -set filename:n '%p' rain.gif 'frame_%[filename:n].jpg' 解释： 第一种方式 %d 是 C 语言 printf() 中表示输出一个整数，参考 -adjoin 选项。 第二种为常规方式。 -set：设置图像属性，格式为 -set key value filename:n &#39;%p&#39;：以 filename: 开头的 key 用于设置输出文件名的相关信息，如这里使用 filename:n，在输出文件名时，则可以使用 %[filename:n] 拿到刚刚的设置，而设置的内容则是 &#39;%p&#39;。&#39;%p&#39; 表示图像在图像列表中的索引值，更多百分比选项 ( Percent Escapes ) 参考。 5.3、解析特定帧如果只想拿到 GIF 的第一帧，可以这样设置。 1convert -coalesce 'rain.gif[0]' first_frame.jpg 拿到某些帧，如同 -clone 的写法。 1convert -coalesce 'rain.gif[0-2]' some_frames_%d.jpg 5.4、获取页数通过 identify 命令我们可以简要得到文件的信息，如下。1identify rain.gif 通过换行符分割，简单封装一个 Node.js 函数获取页数。 123456789101112// parser.jsconst util = require('util')const exec = util.promisify(require('child_process').exec)exports.numberOfPages = async (filePath) =&gt; &#123; try &#123; const &#123; stdout &#125; = await exec(`identify '$&#123;filePath&#125;'`) return stdout.trim().split('\\n').length &#125; catch (err) &#123; throw new Error(err) &#125;&#125; 1234567// main.jsconst &#123; numberOfPages &#125; = require('./parser');(async function start () &#123; const pages = await numberOfPages('rain.gif') console.log('pages:', pages)&#125;()) 5.5、图片转 GIF1convert -loop 0 'frame-*.jpg' rain_animation.gif 将所有与 frame-*.jpg 模式匹配的图像转换成一张 GIF 图像，如 frame-0.jpg，frame-1.jpg等。-loop 设置动画循环次数，0 表示无限循环。设置每张图像的播放速度可以使用 -delay 选项。 笔记： 在 IM 读取系列文件时，frame-10.jpg 会排在 frame-2.jpg 前面，为获得图像正确的读取顺序，可以为文件名设置前导零 ( leading zeros )。如：frame-000.jpg, frame-001.jpg, frame-002.jpg ... frame-010.jpg。 所以在生成图像时，我们可以使用 %03d 获得三位前导零。1convert -coalesce rain.gif frame-%03d.jpg 6、PDF 与图片互转PDF 与图片互转跟 GIF 很相似，稍微有些格式自身需要注意的区别。IM 本身是不具备解析 PDF 的功能的，需要依赖专门解析这种格式的外部程序，如官方指明的 ghostscript 解析程序。首先安装 gs，还是演示 Mac OS 安装：brew install ghostscript。 以 这个PDF 为例，把它转换成图片，有两种方式达到我们想要的结果:1① convert -density 150 -flatten 'download.pdf[0]' first_page.jpg 1② convert -density 150 -background white -alpha remove download.pdf download.jpg 解释： 当转换 PDF 成 JPG 格式图像时，某些情况得到的 JPG 图片会出现黑色背景（转换成 PNG 不会），所以可以使用 -flatten 选项让其保持白色背景，但加上这个选项，多页 PDF 不会分成多个 JPG 图像，第二种方式 -background white -alpha remove 则可以一次命令转换多页 PDF 成多个图像并保持白色背景。 第二种方式 IM 内部应该是一页一页的转换，所以一个 10 页的 PDF 耗时会比较久，采用第一种方式让 Node.js 多进程同时转换该 PDF 可以提升速率。 -density：指定输出图像的分辨率 ( DPI )，在 Mac OS 上，默认的分辨率 ( 72 ) 输出的图像字迹不清，需要更高分辨率获得清晰的图像。 在 Node.js 中应用 直接通过 child_process 模块执行相应的命令即可，如下。 只需要结果可以使用 exec，1234567891011const util = require('util')const exec = util.promisify(require('child_process').exec);(async function start () &#123; try &#123; await exec(`convert -resize '150x100!' -strip goods.jpg thumbnail.jpg`) console.log('convert completed.') &#125; catch (err) &#123; console.log('convert failed.', err) &#125;&#125;()) 流式输入输出可以使用 spawn，1234567891011121314const cp = require('child_process')const fs = require('fs')const args = [ '-', // 使用标准输入 '-resize', '150x100!', '-strip', 'jpg:-', // 输出到标准输出]const streamIn = fs.createReadStream('/path/to/goods.jpg')const proc = cp.spawn('convert', args)streamIn.pipe(proc.stdin)proc.stdout.pipe(HttpResponse)","pubDate":"Wed, 06 Jun 2018 12:30:35 GMT","guid":"https://aotu.io/notes/2018/06/06/ImageMagick_intro/","category":"Web开发"},{"title":"Nerv实战 - 京东首页改版小结","link":"https://aotu.io/notes/2018/04/24/jdindex_2017/","description":".post strong { font-weight: bold; }","pubDate":"Tue, 24 Apr 2018 12:10:00 GMT","guid":"https://aotu.io/notes/2018/04/24/jdindex_2017/","category":"项目总结"},{"title":"Nerv - 京东高性能前端框架","link":"https://aotu.io/notes/2018/03/22/nerv/","description":"Nerv 是一款由京东凹凸实验室打造的类 React 前端框架。目前已广泛运用在京东商城（JD.COM）核心业务及TOPLIFE全站。Nerv 基于React标准，使用 Virtual Dom 技术，拥有和 React 一致的 API 与生命周期，如果你已经对 React 使用非常熟悉，那么使用 Nerv 开发对你来说绝对是零学习成本。 与此同时，相比于 React 以及市面其他同类型框架，Nerv 更具体积轻量，性能高效的特点。并且，它符合当下国情，可以完美兼容 IE8 及以上浏览器。 官网：https://nerv.aotu.io/ 文档：https://nervjs.github.io/docs/ GitHub：https://github.com/NervJS/nerv 特性 更小的体积：Gzip 后仅有9k，不到 React 三分之一的体积，低性能设备也能高速地加载并解析执行。 更高的性能：高效、同步的 diff 算法和诸多优化策略使得 Nerv 成为性能最高的前端框架之一。 完备的生态：无需 nerv-compat，只需要在稍稍设置就能享受整个 React 生态的共同成果。 更一致的渲染：不仅在浏览器上能高效地渲染，在服务器上 Nerv 同样能高效地运行。 更优的兼容：和大多数现代框架不同，Nerv 将继续保持对 IE8 的兼容。 更具说服力的案例：不管是京东首页的高流量，还是 Toplife 的复杂业务，Nerv 都经受住了来自于真实业务的考验。 性能在 Nerv 开发过程中，我们针对虚拟 Dom 算法做了一次升级，将并行的虚拟 Dom diff 过程替换成同步的，边 diff 边 patch ，这样大幅度提升了虚拟 Dom 更新的速度。同时我们还对diff算法进行了探索升级，参照目前市面上最快的虚拟 Dom 算法对我们的代码进行了改造。 经过重构升级后，我们的框架性能大幅提升，如下可见。 更多性能数据详见官网。 项目背景是的，我们又造了一个轮子，也是一次抛离传统开发模式的技术革新。同行们或许有疑问，目前市面上已经有非常多的同类型技术框架，为什么我们还要不厌其烦地打造一个呢？这当然不是在做无用功。 日常开发中，相对于 Vue ，我们更倾向于选择 React 模式作为我们的开发标准，因为 React 天生组件化且函数式编程的方式，更加灵活且便于维护。然而，React 仍然有一些不能满足我们需求的地方： IE8 浏览器兼容性：当前环境所限，即便很不情愿，我们仍然要支持 IE8。 体积：React 大概 130kb 的体积。在低网速 / 低版本浏览器 / 低配置设备的加载速度和解析速度都不能让我们满意。 性能：React 的 Virtual Dom 算法（React 自己叫 Reconciler）并没有做太多的优化。 而我们的新轮子 —— Nerv，它完全能提供上述 React 的所有优点，并且它也能完全满足我们自己的需求：更好的兼容性、更小的体积、更高的性能。 安装推荐使用 npm 的方式进行开发，享受 Node 生态圈和 Webpack 工具链带来的便利。 1npm install nervjs --save 简单示例下面是一个计时器的例子。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import Nerv from 'nervjs'class Counter extends Nerv.Component &#123; setTime = () =&gt; &#123; const date = new Date() const year = date.getFullYear() const month = date.getMonth() + 1 const day = date.getDay() const hour = date.getHours() const minute = date.getMinutes() const sec = date.getSeconds() this.setState(&#123; year, month, day, hour, minute, sec &#125;) &#125; componentWillMount () &#123; this.setTime() &#125; componentWillUnmount () &#123; clearInterval(this.interval) &#125; componentDidMount () &#123; this.interval = setInterval(this.setTime, 1000) &#125; componentWillReceiveProps () &#123; this.setTime() &#125; render () &#123; const &#123; year, month, day, hour, minute, sec &#125; = this.state return ( &lt;div className='counter'&gt; &lt;span&gt;The time is&lt;/span&gt;&#123;year&#125;-&#123;month&#125;-&#123;day&#125; &#123;hour&#125;:&#123;minute&#125;:&#123;sec&#125; &lt;/div&gt; ) &#125;&#125;export default Counter 更多详细例子可阅读文档NervJs了解。 写在最后秉承万维网的开放精神，以及开源世界的信条，我们接受各种评价和讨论，最终目标是为开源世界贡献我们的一份力，感恩！欢迎各位同行使用 Nerv，如果你在使用过程中遇到问题，或者有好的建议，欢迎给我们提Issue 或者 Pull Request。 结尾小彩蛋&gt;&gt; 一个视频带你看懂Nerv","pubDate":"Thu, 22 Mar 2018 04:00:00 GMT","guid":"https://aotu.io/notes/2018/03/22/nerv/","category":"Web开发"},{"title":"动画：从 AE 到 Web","link":"https://aotu.io/notes/2018/03/06/ae2web/","description":"呃~貌似好久没写文章了，感觉有点奇怪。废话不多说，但还是加点前戏吧。 不想听废话，直入主题&gt;&gt; 前戏为何要写这篇文章 接下来因工作调整，应该就很少接触 H5 开发了。借此机会总结对动画的一些个人思考。 本文贴合实战，会结合笔者为数不多的开发案例进行讲解🤣。最后，也会提供相应文件让你实践。 为何“别人”实现的动效恰到好处？同一份设计稿给到不同开发者，结果可能千差万别。而结果主要由两部分体现——内在与外在。『内在』指的是代码质量、性能优化，『外在』则指的是视觉还原度和动效（交互）。 其中对于更直观的『外在』来说，视觉还原度高是前提，真正体现差距的是『动效』。因为设计师一般只给到“静态”的视觉稿，而无动画演示，更不用说提供动效搞（如 AE）了。 在这种情况下，页面的动效更多是由前端开发者自由发挥。因此对动效有钻研的同学优势尽显。他们积累了一定理论知识和经验。我也曾问过这些同学，他们大多回答是：“多试多调”。因此，在设计师无『动效稿』提供的情况下，都需要花时间慢慢调整，以达到各方（自己、设计师、产品和需求方等）满意。若没有设计、动效等相关知识的学习与积累，恐怕是一只『没头苍蝇』。 关于动画的理论方面，笔者并没有积累，但推荐一些不错的资料（或许需要梯子）。同时也希望得到读者们的有效补充： 动画的十二原则——12 Principles of Animation (Official Full Series) 动画的第一步是『观察』——Exploring Animation And Interaction Techniques With WebGL (A Case Study)，译文&gt;&gt; 其实可以把『锅』扔给设计师大多数前端开发者在设计和动效方面并没有太多积累，因而难以做出令人拍手称赞的效果。其实，这是设计师（或动效设计师）所擅长的领域，可从下表查看两者的对比： * 设计师 前端开发 备注 是否擅长动画 大部分 少部分 如何生产动画 GUI 工具，如 AE 编写代码 效益 高 低 体现在以下几个方面： 1. 专业度 2. 实现效率：可视化 &gt; 编写代码 3. 沟通成本 4. 各方满意度 5. … 从上表可得，将『动效设计』交给设计师能显著提高效益。从实际工作流程上说： 设计师与前端开发的排期由『线性』变为『部分重叠』：设计师交付静态视觉稿后，前端开发就能进行视觉还原，设计师此时即可进入动效设计。 设计师将动效设计导出为视频，提前取得各方满意度，避免开发期间的反复沟通修改。 假设达成以上共识后，剩下的问题就是：如何还原『动效稿』？ 补间动画——Apple 逐帧动画——洗衣机 设计师输出的动效演示 注：全文『动效稿』均基于 Adobe After Effects（简称 AE）设计。 AE 到 Web 实现其实，与『制造业』一样，实现方式就两种： 机械：通过工具直接导出 手工：手动取参数，通过掌握的 Web 技术实现 两者的优缺点比较： * 机械 手工 效率 高 低 精度 高 视情况而定 定制化 低 高 情怀 无 因人而异 机械实现机械代表着“未来、高效”。业界出现了很多优秀的工具，使得在浏览器渲染复杂动效成为了可能，且极大地提高了效率。 代表工具有： Bodymovin 是 AE 的一个插件，用于将 AE 导出为 Web 动画（HTML、SVG 或 Canvas），仅支持 AE 部分特性。 lottie-web 是 Airbnb 团队的一个用于在 Web、Android、iOS 和 React Native 渲染 AE 动画的库。 可是『世界上本来就没有十全十美的东西』。机械化生产可能未必满足所有要求，生产环境上的要求就更加苛刻了。主要体现在：机械化生产导致介入难度高。若出现以下问题就难以解决： 兼容性 在动画过程中插入自定义逻辑 工具自身的不完善 文件体积要求 … 无论如何，『机械化』是未来，期待它以完美的姿态到来。 手工实现手工代表着“自定义、可控性”。无论世界如何工具化，总有一些人保持着对『手工』的热情。 『手工』意味着从无到有的过程。需要我们参与这个过程的每一步。这也就使得我们拥有了很强的自定义能力。这恰恰是『机械化』目前所不具备的特性。这也是本文重点阐述的内容。 基于 AE 手工实现 Web 动画的主要工作有两个： 在动效稿上拿到元素的参数信息，如 x/y/z、rotation 等 通过适当的 Web 技术进行实现，如 CSS3/Canvas/SVG 等 如何手工取参Web 动画一般分为 逐帧动画 和 补间动画。 显然，对于取参操作来说，逐帧动画比补间动画的工作量要大得多，但两者操作一致。所以下面以 补间动画 Apple 为例： 打开 apple.aep 文件，AE 界面如下： AE 界面 点击『信息模块』预览面板的播放按钮或拖动『时间轴模块』的 标记3 即可预览动画。 根据 CSS3 animation 属性，我们需要获取以下信息： 动画持续时间 animation-duration 关键帧之间的缓动函数 animation-timing-function 动画延时时间 animation-delay 为了方便阐述，我们选取整个 Apple 动画中一个小圆圈（共 60 个）为代表，其余元素同理。另外，由于该动画是一次性的，无需设置/获取动画的重复次数（animation-iteration-count）、运动方向（animation-direction）。 现在我们把目光投向『图层、运动模块』的 标记1： 标记1——FPS 由上图可得，FPS 为 12，即 1 秒 12 帧， 1 帧 0.0833 秒。 由上面 Apple 动画 可看出，每个圆的延时时间（animation-delay）、缓动函数（animation-timing-function）和持续时间（animation-duration）均不相同。换句话说，每个圈都是一个独立的补间动画，所有元素组合起来才是一个完整的补间动画。 双击『标记 2』，进入编组以查看每个圆的信息。 子元素——圆 在『查看器』或『图层、运动模块』任意选中一个圆，展开其 变换 属性并单击 位置（标记1），即可显示右侧的元素运动路径（标记2）。同时这也反映了属性的变化速率（即缓动函数（animation-timing-function），这方面会在后面详解。 位置 前面的时钟图标为蓝色时，代表有过渡动画。 某个圆的时间轴 结合上面知识，可从上图得出以下信息点： 该元素共有 4 个关键帧 只有 Y 轴上发生位移运动（绿线），X 轴上则是静止状态（红线） 延时时间为 1 帧 中间停留时间（第2、3 关键帧之间）为 1 帧 过渡时间为 42 帧（3 12 + 7 - 1）。*注意要减去延时时间（1），因为 02:03 包含了它。下同。 因此，我们基于 CSS3 animation 实现该元素的补间动画： 1&lt;div class=\"circle-29\"&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930/* 默认定位在第2（或3）帧以让元素默认显示屏幕内，便于开发调试。 */.circle-29 &#123; width: 60px; height: 60px; background-color: rgba(0, 224, 93, .7); position: absolute; left: 473px; top: 348px; border-radius: 50%; animation-name: circle29; animation-duration: 3.5s; /* 42 * (1 / 12) */ animation-delay: 0.0833s; /* 1 * (1 / 12) */ animation-fill-mode: both; animation-timing-function: ease-in-out;&#125;@keyframes circle29 &#123; 0% &#123; transform: translate3d(0, 1175px, 0); &#125; 61.90% &#123; /* (2 * 12 + 3 - 1) / 42，注意要减去延时时间（1），因为 02:03 包含了它。下同。*/ transform: translate3d(0, 0, 0); &#125; 64.29% &#123; transform: translate3d(0, 0, 0); &#125; 100% &#123; transform: translate3d(0, -1225px, 0); &#125;&#125; 这样就完成了某个圆的补间动画了。虽然繁琐，但是省去反复试验的时间，基本做到一次开发即可使各方满意的效果。 See the Pen ae2web-circle by Jc (@JChehe) on CodePen. 其余元素按照以上步骤执行即可完成整个动画。 假设没有动画演示和动效稿，仅凭借着个人感觉，编码完成一个由 60 多个元素组成的动画，简直难于上青天（对于笔者来说）。 也许你对 animation-timing-function 存在误解细心的读者可能发现：如果第 1、2 帧和第 3、4 帧的缓动函数不相同时，该怎么办？ 首先部分人可能对 animation-timing-function 存在误解：它是作用于整个 @keyframes 规则的。❌ 其实缓动函数是作用于 @keyframes 规则内的关键帧。若未为关键帧指定 animation-timing-function，则会从其元素取得 animation-timing-function。 更严格地说，缓动函数是应用在属性上，从定义该属性的关键帧到下一个指定同样属性的关键帧。若后续无指定该属性的关键帧则到动画结束。因此，在 100% 或 to 关键帧上指定 animation-timing-function 是无用的。 举个例子：12345678910111213141516171819202122.box &#123; width: 100px; height: 100px; background-color: #6190e8; animation: move 2s ease both;&#125;@keyframes move &#123; 0% &#123; animation-timing-function: linear; transform: translateX(0); opacity: 1; &#125; 50% &#123; opacity: .5; &#125; 100% &#123; transform: translateX(100px); opacity: 1 animation-timing-function: ease-in-out; /* 无用多余 */ &#125;&#125; 在 0% 关键帧中指定的 animation-timing-function: linear 是对 transform 和 opacity 属性有效。但因为 50% 关键帧未指定 transform 属性，所以 animation-timing-function: linear 对它生效至有指定 transform 属性的关键帧，即 100%。 另外，由于 50% 关键帧未指定 animation-timing-function，所以它会使用 .box 元素上指定的 ease 缓动函数。 总上所述，可在关键帧上指定不同的缓动函数，以满足关键帧间属性的不同变化速率。 更强大的 cubic-bezier细心的读者可能又发现：缓动函数碰巧是 预定义的关键字，如果是以下这种情况呢？ 显然浏览器预定义的关键字无法表示该类型的缓动函数，但浏览器提供了强大的 cubic-bezier() 方法。翻译过来就是三次贝塞尔曲线。因此，我们可以通过该方法自定义缓动函数。 想了解贝塞尔曲线的更多知识，可阅读 《贝塞尔曲线扫盲》。 AE 时间轴 上呈现的是属性的变化路径，其未必与变化速率（即缓动函数）完全一致。因为它们的 X/Y 轴含义不同。 如上图所示，AE 是属性随着时间而变，CSS3 animation 是动画进度随着时间而变。然而属性的变化是有方向的，动画进度是永远向前的。 举个例子： AE：AE 属性变化是有方向的 对应 CSS3 animation-timing-function：动画进度永远是向前的 如上面二图所示，下图是上图的速率变化（缓动函数）。理清 AE 与 CSS3 animation 的对应关系后，剩下的问题就是：如何通过 cubic-bezier() 表示图中的 CurveA 与 CurveB。 也许有工具可从 AE 直接导出（欢迎读者们提供链接），但本文为了简单起见，推荐使用 Ceasar 或 Cubic-Bezier.com 这类可视化工具直接模拟生成。 因此，上述补间动画的缓动函数可表示为： 12345678910111213141516@keyframes ae2css &#123; 0% &#123; animation-timing-function: ease-out; &#125; 23% &#123; animation-timing-function: ease-in; &#125; 50% &#123; animation-timing-function: cubic-bezier(0.5, 0, 0.5, 1.5); &#125; 76% &#123; animation-timing-function: cubic-bezier(0, 0, 0, 1); &#125; 100% &#123; &#125;&#125; 总结本文基于实际案例总结出 AE 到 Web 动画的实现方法。相对于『无动效稿』的反复编码尝试，该方法无疑能提高效益。当然，『手工』不能胜任复杂的动画（如 SVG 的变形动画（Morphing）），并且低效。因此，业界也在『机械/工具化』方面不断推陈出新，涌现出许多优秀的工具，让复杂的动画在各终端上得以表现。无论如何，学习更多知识总没错! 最后，感谢你的阅读！ 案例演示以下案例演示未完全按 AE 动效稿的参数。若感觉不太对劲，那也许是正常的吧!？ Apple 补间动画整体效果演示（一次性动画，请点击 “RERUN” 按钮重播）： See the Pen ae2css-apple by Jc (@JChehe) on CodePen. 洗衣机逐帧动画同理（主要针对背景图的 3D 旋转进行处理）：链接&gt;&gt; 移动端体验地址： Apple 洗衣机 素材下载 Apple 补间动画 AE 文件 参考资料 Making the transition from animating in After Effects to CSS. MDN: animation-timing-function","pubDate":"Tue, 06 Mar 2018 04:00:00 GMT","guid":"https://aotu.io/notes/2018/03/06/ae2web/","category":"Web开发"},{"title":"H5游戏开发：FC小蜜蜂","link":"https://aotu.io/notes/2018/01/28/galaxian/","description":"前言说起任天堂 FC 那是充满我们童年寒暑假的回忆，那时候没有正版红白机，玩的是几十块一台的山寨小霸王，十块一张的卡带，玩着魂斗罗、马里奥、淘金者、快打旋风、打鸭子等等。 进入正题，今天我们来说说怎么做一个 FC 小蜜蜂游戏，游戏玩法是通过操控飞机，通过发射子弹对蜜蜂造成伤害，蜜蜂全部歼灭则视为胜利。 初始化本次游戏采用 Phaser 引擎进行开发，Phaser 是一个快速、免费、易于维护的开源 2D 游戏框架，支持 JavaScript 和 TypeScript 两种语言开发，采用 Pixi.js 引擎作为底层渲染，内置了物理引擎、粒子动画、骨骼动画等效果。 在 Phaser 中有一个重要的概念，我们需要通过状态（State）来管理游戏中各个不同的场景，这也是 Phaser 官方建议的游戏代码组织方式，场景可以通过 Phaser.Game.state 来添加（add）和启动（start），每个场景有初始化（init）、预加载（preload）、准备就绪（create）、更新周期（update）、渲染完毕（render） 五种状态，按照顺序依次执行，同一时间只能存在一个场景，并且每个场景中至少包含五种状态中的一个。 比如我们的小蜜蜂游戏一共会分为四个场景：开始场景、游戏场景、获胜场景、失败场景 1234567891011121314151617181920212223var game = new Phaser.Game(750, 1206, Phaser.AUTO, 'wrapper')var states = &#123;&#125;states.start = &#123; // 开始场景 preload: function() &#123; ... game.load.image('example-1', 'images/example-1.png') ... &#125;, create: function() &#123; game.state.start('play') // 加载完成后切换到游戏场景 &#125;&#125;states.play = &#123; ... &#125; // 游戏场景states.victory = &#123; ... &#125; // 胜利场景states.defeat = &#123; ... &#125; // 失败场景game.state.add('start', states.load)game.state.add('play', states.play)game.state.add('victory', states.victory)game.state.add('defeat' states.defeat)game.state.start('start') 无限滚屏在无限滚屏中，游戏背景沿着 x 轴或者 y 轴重复的滚动，从而实现飞机一直在向前飞的错觉，我们通过创建两个背景，分别初始定位到一屏和二屏的位置，在绘制（update）的过程中持续移动两张背景图的 y 轴，当监听到两个背景超出特定位置后重新定位，从而达到无限循环背景的效果。 1234567891011var bg1 = game.add.image(0, 0, 'background'), bg2 = game.add.image(0, -bg1.height, 'background')update: function() &#123; // 持续的移动 bg1.y += 2 bg2.y += 2 // 超出屏幕判断 if (bg1.y &gt;= 1206) &#123; bg1.y = 0 &#125; if (bg2.y &gt;= 0) &#123; bg2.y = -bg1.height &#125;&#125; 当然，还有更为简便的方式，Phaser 提供了 TileSprite 平铺纹理，非常适合于这类平铺的背景，再结合 autoScroll() 方法，两行代码解决，另外还有一种叫 TileMaps 平铺的瓦片地图，很适合制作 FC 马里欧这类游戏，以后有机会再开一篇文章讲讲。 12var bg = game.add.tileSprite(0, 0, 750, 1206, 'background')bg.autoScroll(0, 200) // 水平滚动速度、垂直滚动速度 创建一架飞机飞机的移动我们通过键盘方向键进行控制，通过修改 x、y 值来实现位移，为了有更好的灵活性，我们使用 vx 和 vy 来控制 Sprite 的移动，vx 用于设置 Sprite 在 x 轴上的速度和方向，vy 用于设置 Sprite 在 y 轴上的速度和方向，不直接修改 Sprite 的 x 和 y 值，而是先更新速度值，然后再将这些速度值分配给 Sprite。 123456789...airplane.vx = 0airplane.vy = 0update: function() &#123; airplane.x += airplane.vx airplane.y += airplane.vy&#125;... 接着监听键盘事件，需要注意的就是在弹起状态的时候要判断反向的键是否也已经弹起，避免造成互相干扰。 1234...left.onDown.add(function() &#123; airplane.vx = -8 &#125;)left.onUp.add(function() &#123; if (!right.isDown) &#123; airplane.vx = 0 &#125; &#125;)... 最后是限制飞机的移动范围，我们要限制飞机只在屏幕范围内移动，类似空气墙效果，通过持续监听飞机上下左右四个方向是否碰触到边缘，对坐标进行归位，具体实现代码请看 contain 方法。 生成子弹在游戏中，我们需要不断的发射子弹，这就存在一个问题，如何管理子弹？ 因为子弹越多会越占用我们的内存，游戏会发现越来越卡，我们使用对象池的方式生成子弹，并且在子弹击中蜜蜂或者超出屏幕时进行销毁。 对象池的本质是复用，通过 Group 和 getFirstExists 来实现。在优化前，我们每次创建子弹都会 new Sprite，使用一次后就丢掉，优化后是创建子弹后会放入对象池中，每次使用从对象池中取，如果对象池中有则使用对象池中的子弹。 12345678910this.bullets = game.add.group() // 创建对象池var bullet = this.bullets.getFirstExists(false) // 从对象池中取非存活状态的子弹if (bullet) &#123; // 对象池中存在则复用 bullet.reset(this.airplane.x + 16, this.airplane.y - 20)&#125; else &#123; // 对象池中不存在则创建一个放入对象池中 bullet = game.add.sprite(this.airplane.x + 27, this.airplane.y - 15, 'bullet') this.bullets.addChild(bullet)&#125; 创建一群蜜蜂整体移动创建 5 x 5 小蜜蜂是采用 Group 将所有的小蜜蜂对象放入其中，持续移动 Group，检测 Group 左右是否碰壁，进行反方向移动，但你会发现小蜜蜂的左右的某一列被歼灭后，Group 的宽度会随着小蜜蜂列数的变化而变化，而 Group 的 X 轴坐标还是以原来的宽度输出 X 坐标，这就导致我们在计算碰撞墙壁的时候出现问题。 因此我们改为通过 Group 来控制整体移动，小蜜蜂负责碰撞检测，当检测到小蜜蜂碰撞后，进行反方向移动，并跳出循环。 1234567for (var i = 0; i &lt; galaxians.length; i++) &#123; var cur = galaxians[i] if (cur.x + cur.parent.x &lt; 0 || cur.x + cur.parent.x + cur.width &gt; game.world.width) &#123; // 反向移动 break &#125;&#125; 随机自杀式袭击在间隔一段时间后随机小蜜蜂发起攻击，间隔不采用 setInterval 的方式，因为 setInterval 即使在页面最小化或非激活状态依然执行，我们采用 Phaser 提供的 Time 进行间隔触发避免此问题。 1234game.time.events.loop(Phaser.Timer.SECOND * 1.5, function() &#123; // 每两秒随机一只小蜜蜂 var now = galaxians[(Math.floor(Math.random() * galaxians.length)]&#125;) 如何计算小蜜蜂向飞机发起攻击的运动轨迹，这里要借助三角函数的力量来解决，通过飞机位置和蜜蜂位置，获得对边（a）和邻边（b）的长度，根据勾股定理求出斜边（c）长度，知道各边长度后就能得到三角比。另外有一点，Group 的 X 轴在持续的移动，小蜜蜂会受 Group 影响，所以在移动小蜜蜂时要注意。 12345678var a = airplane.x + airplane.width / 2 - now.x + now.width /2 // 获取 a 边长度var b = airplane.y + airplane.height / 2 - now.y + now.height / 2 // 获取 b 边长度var c = Math.sqrt(a * a + b * b) // 求出斜边 c 长度var speedX = a / c * 8var speedY = b / c * 8now.x += speedXnow.y += speedY 碰撞检测在游戏中，我们需要检测子弹与蜜蜂的碰撞和检测蜜蜂与飞机的碰撞，在 2D 游戏中，常用的有轴对齐包围盒（简称 AABB）就是一个每条边都平行于 X 轴或者 Y 轴的矩形。 AABB 可以用两个点表示：最大点和最小点，在 2D 中，最小点就是左下角的点，而最大点则是右上角的点。 通过判断 AABB 与 AABB 是否有存在交叉即可得知是否有碰撞。 12345function hitTestRectangle(a, b) &#123; var hit = (a.max.x &lt; b.min.x) || (b.max.x &lt; a.min.x) || (a.max.y &lt; b.min.y) || (b.max.y &lt; a.min.y) &#123; return !hit &#125;&#125; 以上就是 AABB 与 AABB 碰撞检测的原理，当然，你也可以省事采用 Phaser 提供的物理引擎，在 Phaser 中内置了三种物理引擎，分别是：Arcade Physics、P2 Physics 和 Ninja Physics。 Arcade Physics：是三个中最为简单、性能最快的物理引擎，因为它的碰撞都是采用 AABB 与 AABB 的碰撞，所有的碰撞都是基于一个矩形边界（hitbox）来计算的，所有如果你想碰撞一个圆形的 Sprite，碰撞的则是它的矩形边界，而不是圆形本身，并且支持摩擦力、重力、弹跳、加速等物理效果，适合应用于精度要求不高，较为简单的游戏中。 P2 Physics：它是一个更为复杂和逼真的物理引擎，使用 P2 你可以创建弹簧、钟摆、马达等东西，它唯一的缺点在于运算量大，对于性能有较高的要求。 Ninja Physics：比 Arcade Physics 要复杂一点，最初是为 Flash 游戏而创造的，而现在由 Phaser 的作者 Richard Davey 移植到 JavaScript，它与其他物理引擎最大的区别在于支持斜坡碰撞。 下面简单介绍一下 Arcade Physics 的使用方法，首先要启动物理引擎 1game.physics.startSystem(Phaser.Physics.ARCADE); 接着是需要为每个对象开启物理效果，显然一个个创建、添加对象并不高效，我更建议的是通过 Group 的形式添加，这样在 Group 上创建的对象都可以开启物理效果。 12345game.physics.arcade.enable(airplane) // 单独开启方式var platforms = game.add.group()platforms.enableBody = true // 组开启方式platforms.create(0, 0, 'airplane') 完成这些以后就可以在 update 阶段使用碰撞检测，overlap 方法可传入两个游戏对象，对象可以是 Sprites、Groups 或者 Emitters，可以执行 Sprite 与 Sprite、Sprite 与 Group、Group 与 Group 的碰撞检测，与 collide 方法不同，该方法的物体不会执行任何的物理效果，它只负责碰撞检测。 123update: function() &#123; game.physics.arcade.overlap(object1, object2, overlapCallback, processCallback, callbackContext)&#125; 到此碰撞检测介绍就到这，关于物理引擎的更多使用方法可移步至官网查看。 体验地址【点击这里体验】键盘方向键控制移动，空格发射子弹，暂时只支持 PC 端体验，另外游戏还有很多可增加的功能，比如：关卡设计（蜜蜂血量、速度、分数）、蜜蜂发射子弹、蜜蜂贝塞尔曲线移动、蜜蜂归位、音乐音效、爆炸动画等等。 尾巴如果你希望入门 H5 游戏开发，不妨拿这个练练手，源码你可以在体验地址中查看到，Phaser 是很适合作为你入门 H5 游戏开发的一款游戏引擎，等你熟练使用也希望你能阅读源码，了解其中的原理，本文较为简单，感谢你的阅读。 我们会定期更新关于「H5游戏开发」的文章，欢迎关注我们的知乎专栏。 参考资料Learning Pixi.jsPhaserSetting up Ninja Physics in Phaser《游戏编程算法与技巧》","pubDate":"Sun, 28 Jan 2018 14:37:01 GMT","guid":"https://aotu.io/notes/2018/01/28/galaxian/","category":"H5游戏开发"},{"title":"H5游戏开发：消灭星星","link":"https://aotu.io/notes/2018/01/17/popstar/","description":"「消灭星星」是一款很经典的「消除类游戏」，它的玩法很简单：消除相连通的同色砖块。 1. 游戏规则「消灭星星」存在多个版本，不过它们的规则除了「关卡分值」有些出入外，其它的规则都是一样的。笔者介绍的版本的游戏规则整理如下： 1. 色砖分布 10 x 10 的表格 5种颜色 —— 红、绿、蓝，黄，紫 每类色砖个数在指定区间内随机 5类色砖在 10 x 10 表格中随机分布 2. 消除规则 两个或两个以上同色砖块相连通即是可被消除的砖块。 3. 分值规则 消除总分值 = n * n * 5 奖励总分值 = 2000 - n * n * 20 「n」表示砖块数量。上面是「总」分值的规则，还有「单」个砖块的分值规则： 消除砖块得分值 = 10 * i + 5 剩余砖块扣分值 = 40 * i + 20 「i」表示砖块的索引值（从 0 开始）。简单地说，单个砖块「得分值」和「扣分值」是一个等差数列。 4. 关卡分值 关卡分值 = 1000 + (level - 1) * 2000；「level」即当前关卡数。 5. 通关条件 可消除色块不存在 累计分值 &gt;= 当前关卡分值 上面两个条件同时成立游戏才可以通关。 2. MVC 设计模式笔者这次又是使用了 MVC 模式来写「消灭星星」。星星「砖块」的数据结构与各种状态由 Model 实现，游戏的核心在 Model 中完成；View 映射 Model 的变化并做出对应的行为，它的任务主要是展示动画；用户与游戏的交互由 Control 完成。 从逻辑规划上看，Model 很重而View 与 Control 很轻，不过，从代码量上看，View 很重而 Model 与 Control 相对很轻。 3. Model10 x 10 的表格用长度为 100 的数组可完美映射游戏的星星「砖块」。 123456789101112[ R, R, G, G, B, B, Y, Y, P, P, R, R, G, G, B, B, Y, Y, P, P, R, R, G, G, B, B, Y, Y, P, P, R, R, G, G, B, B, Y, Y, P, P, R, R, G, G, B, B, Y, Y, P, P, R, R, G, G, B, B, Y, Y, P, P, R, R, G, G, B, B, Y, Y, P, P, R, R, G, G, B, B, Y, Y, P, P, R, R, G, G, B, B, Y, Y, P, P, R, R, G, G, B, B, Y, Y, P, P] R - 红色，G - 绿色，B - 蓝色，Y - 黄色，P - 紫色。Model 的核心任务是以下四个： 生成砖墙 消除砖块 （生成砖块分值） 夯实砖墙 清除残砖 （生成奖励分值） 3.1 生成砖墙砖墙分两步生成： 色砖数量分配 打散色砖 理论上，可以将 100 个格子可以均分到 5 类颜色，不过笔者玩过的「消灭星星」都不使用均分策略。通过分析几款「消灭星星」，其实可以发现一个规律 —— 「色砖之间的数量差在一个固定的区间内」。 如果把传统意义上的均分称作「完全均分」，那么「消灭星星」的分配是一种在均分线上下波动的「不完全均分」。 笔者把上面的「不完全均分」称作「波动均分」，算法的具体实现可以参见「波动均分算法」。 「打散色砖」其实就是将数组乱序的过程，笔者推荐使用「 费雪耶兹乱序算法」。 以下是伪代码的实现：1234567// 波动均分色砖waveaverage(5, 4, 4).forEach( // tiles 即色墙数组 (count, clr) =&gt; tiles.concat(generateTiles(count, clr)); ); // 打散色砖shuffle(tiles); 3.2 消除砖块「消除砖块」的规则很简单 —— 相邻相连通相同色即可以消除。 前两个组合符合「相邻相连通相同色即可以消除」，所以它们可以被消除；第三个组合虽然「相邻相同色」但是不「相连通」所以它不能被消除。 「消除砖块」的同时有一个重要的任务：生成砖块对应的分值。在「游戏规则」中，笔者已经提供了对应的数学公式：「消除砖块得分值 = 10 * i + 5」。 「消除砖块」算法实现如下：1234567891011121314151617181920function clean(tile) &#123; let count = 1; let sameTiles = searchSameTiles(tile); if(sameTiles.length &gt; 0) &#123; deleteTile(tile); while(true) &#123; let nextSameTiles = []; sameTiles.forEach(tile =&gt; &#123; nextSameTiles.push(...searchSameTiles(tile)); makeScore(++count * 10 + 5); // 标记当前分值 deleteTile(tile); // 删除砖块 &#125;); // 清除完成，跳出循环 if(nextSameTiles.length === 0) break; else &#123; sameTiles = nextSameTiles; &#125; &#125; &#125;&#125; 清除的算法使用「递归」逻辑上会清晰一些，不过「递归」在浏览器上容易「栈溢出」，所以笔者没有使用「递归」实现。 3.3 夯实砖墙砖墙在消除了部分砖块后，会出现空洞，此时需要对墙体进行夯实： 向下夯实 向左夯实 向左下夯实（先下后左） 一种快速的实现方案是，每次「消除砖块」后直接遍历砖墙数组（10x10数组）再把空洞夯实，伪代码表示如下： 123456789101112131415for(let row = 0; row &lt; 10; ++row) &#123; for(let col = 0; col &lt; 10; ++col) &#123; if(isEmpty(row, col)) &#123; // 水平方向（向左）夯实 if(isEmptyCol(col)) &#123; tampRow(col); &#125; // 垂直方向（向下）夯实 else &#123; tampCol(col); &#125; break; &#125; &#125;&#125; But… 为了夯实一个空洞对一张大数组进行全量遍历并不是一种高效的算法。在笔者看来影响「墙体夯实」效率的因素有： 定位空洞 砖块移动（夯实） 扫描墙体数组的主要目的是「定位空洞」，但能否不扫描墙体数组直接「定位空洞」？ 墙体的「空洞」是由于「消除砖块」造成的，换种说法 —— 被消除的砖块留下来的坑位就是墙体的空洞。在「消除砖块」的同时标记空洞的位置，这样就无须全量扫描墙体数组，伪代码如下： 123456function deleteTile(tile) &#123; // 标记空洞 markHollow(tile.index); // 删除砖块逻辑 ...&#125; 在上面的夯实动图，其实可以看到它的夯实过程如下： 空洞上方的砖块向下移动 空列右侧的砖块向左移动 墙体在「夯实」过程中，它的边界是实时在变化，如果「夯实」不按真实边界进行扫描，会产生多余的空白扫描： 如何记录墙体的边界？把墙体拆分成一个个单独的列，那么列最顶部的空白格片段就是墙体的「空白」，而其余非顶部的空白格片段即墙体的「空洞」。 笔者使用一组「列集合」来描述墙体的边界并记录墙体的空洞，它的模型如下： 12345678910111213/* @ count - 列砖块数 @ start - 顶部行索引 @ end - 底部行索引 @ pitCount - 坑数 @ topPit - 最顶部的坑 @ bottomPit - 最底部的坑*/ let wall = [ &#123;count, start, end, pitCount, topPit, bottomPit&#125;, &#123;count, start, end, pitCount, topPit, bottomPit&#125;, ...]; 这个模型可以描述墙体的三个细节： 空列 列的连续空洞 列的非连续空洞 123456789101112// 空列if(count === 0) &#123; ...&#125;// 连续空洞else if(bottomPit - topPit + 1 === pitCount) &#123; ...&#125;// 非连续空洞else &#123; ...&#125; 砖块在消除后，映射到单个列上的空洞会有两种分布形态 —— 连续与非连续。 「连续空洞」与「非连续空洞」的夯实过程如下： 其实「空列」放大于墙体上，也会有「空洞」类似的分布形态 —— 连续与非连续。 它的夯实过程与空洞类似，这里就不赘述了。 3.4 消除残砖上一小节提到了「描述墙体的边界并记录墙体的空洞」的「列集合」，笔者是直接使用这个「列集合」来消除残砖的，伪代码如下： 1234567891011function clearAll() &#123; let count = 0; for(let col = 0, len = this.wall.length; col &lt; len; ++col) &#123; let colInfo = this.wall[col]; for(let row = colInfo.start; row &lt;= colInfo.end; ++row) &#123; let tile = this.grid[row * this.col + col]; tile.score = -20 - 40 * count++; // 标记奖励分数 tile.removed = true; &#125; &#125;&#125; 4. ViewView 主要的功能有两个： UI 管理 映射 Model 的变化（动画） UI 管理主要是指「界面绘制」与「资源加载管理」，这两项功能比较常见本文就直接略过了。View 的重头戏是「映射 Model 的变化」并完成对应的动画。动画是复杂的，而映射的原理是简单的，如下伪代码： 1234567891011121314151617181920212223update(&#123;originIndex, index, clr, removed, score&#125;) &#123; // 还没有 originIndex 或没有色值，直接不处理 if(originIndex === undefined || clr === undefined) return ; let tile = this.tiles[originIndex]; // tile 存在，判断颜色是否一样 if(tile.clr !== clr) &#123; this.updateTileClr(tile, clr); &#125; // 当前索引变化 ----- 表示位置也有变化 if(tile.index !== index) &#123; this.updateTileIndex(tile, index); &#125; // 设置分数 if(tile.score !== score) &#123; tile.score = score; &#125; if(tile.removed !== removed) &#123; // 移除或添加当前节点 true === removed ? this.bomb(tile) : this.area.addChild(tile.sprite); tile.removed = removed; &#125;&#125; Model 的砖块每次数据的更改都会通知到 View 的砖块，View 会根据对应的变化做对应的动作（动画）。 5. ControlControl 要处理的事务比较多，如下： 绑定 Model &amp; View 生成通关分值 判断通关条件 对外事件 用户交互 初始化时，Control 把 Model 的砖块单向绑定到 View 的砖块了。如下： Object.defineProperties(model.tile, { originIndex: { get() {...}, set(){ ... view.update({originIndex}) } }, index: { get() {...}, set() { ... view.update({index}) } }, clr: { get() {...}, set() { ... view.update({clr}) } }, removed: { get() {...}, set() { ... view.update({removed}) } }, score: { get() {...}, set() { ... view.update({score}) } } }) 「通关分值」与「判断通关条件」这对逻辑在本文的「游戏规则」中有相关介绍，这里不再赘述。 对外事件规划如下： name detail pass 通关 pause 暂停 resume 恢复 gameover 游戏结束 用户交互 APIs 规划如下： name type deltail init method 初始化游戏 next method 进入下一关 enter method 进入指定关卡 pause method 暂停 resume method 恢复 destroy method 销毁游戏 6. 问题在知乎有一个关于「消灭星星」的话题：popstar关卡是如何设计的？ 这个话题在最后提出了一个问题 —— 「无法消除和最大得分不满足过关条件的矩阵」。 「无法消除的矩阵」其实就是最大得分为0的矩阵，本质上是「最大得分不满足过关条件的矩阵」。 最大得分不满足过关条件的矩阵求「矩阵」的最大得分是一个 「背包问题」，求解的算法不难：对当前矩阵用「递归」的形式把所有的消灭分支都执行一次，并取最高分值。但是 javascript 的「递归」极易「栈溢出」导致算法无法执行。 其实在知乎的话题中提到一个解决方案： 网上查到有程序提出做个工具随机生成关卡，自动计算，把符合得分条件的关卡筛选出来 这个解决方案代价是昂贵的！笔者提供有源码并没有解决这个问题，而是用一个比较取巧的方法：进入游戏前检查是事为「无法消除矩阵」，如果是重新生成关卡矩阵。 注意：笔者使用的取巧方案并没有解决问题。 7. 结语下面是本文介绍的「消灭星星」的线上 DEMO 的二维码： 游戏的源码托管在：https://github.com/leeenx/popstar 感谢耐心阅读完本文章的读者。本文仅代表笔者的个人观点，如有不妥之处请不吝赐教。如果对「H5游戏开发」感兴趣，欢迎关注我们的专栏。 参考资料 Knapsack problem NP-completeness popstar关卡是如何设计的？ 费雪耶兹乱序算法 波动均分算法","pubDate":"Wed, 17 Jan 2018 13:53:01 GMT","guid":"https://aotu.io/notes/2018/01/17/popstar/","category":"H5游戏开发"},{"title":"波动均分算法","link":"https://aotu.io/notes/2018/01/11/waveaverage/","description":"「波动」和「均分」大部分读者朋友是知道的，但看到「波动均分」应该是一头雾水的。其实，这个名词是笔者拼凑出来的。 什么是「波动均分」？ 把指定的数值 A，分成 N 份，此时每份的数值在一个固定的区间 [max, min] 内。 从视觉上看，每份的数量在平均线上下波动，并带有随机性： 这种分配不是严格意义上的「均分」，但它却跟「均分」很相似，按笔者的理解给这个算法取个名字 —— 「波动均分」。 波动均分算法应该具备的特征如下： 分配数量 波峰高度 波谷深度 随机分配 组合全面 前三个特征是提供对外配置的接口，保证算法的使用者可以指定分配的数量和定制波动的波峰和波谷（尽管大部分情况下，波峰 = 波谷）；「随机分配」表示算法的结果是随机的；「 组合全面」表示算法的结果是可以覆盖所有可能的结果。 接下来，笔者将介绍两种实现「波动均分」的算法： 穷举法 快速分配 备注：本文算法中使用到的平均值是0 穷举法「穷举法」顾名思义就是列举所有可能出现的组合，再随机抽取一个组合作为输出结果。 下面是一个「波动均分」任务： 有一张 10x10 的表格，需要对格子上5种颜色并要求每种颜色的数量在区间 [18, 22] 内。 由上述可得：每种颜色都会有5种分配结果（18, 19, 20, 21, 22）。穷举这些颜色分配数量的组合其实就是建设一棵高度为 6 的 5 叉树的过程。 第 6 层的叶子数就是「所有可能出现的组合」的总数。换而言之，从树的第六层的一片叶子到第二层节点的路径即是一种分配组合。 以下是「穷举法」的代码实现：12345678910111213141516171819202122232425262728293031323334function exhaustWave(n = 5, crest = 4, trough = 4) &#123; let root = &#123;parent: null, count: null, subtotal: 0&#125;; // 根节点 let leaves = [root]; // 叶子（数组） let level = 0; // 层数 // 检查当前组合是否合法 let isOK = subtotal =&gt; &#123; if(level &lt; n - 1) &#123; if(-subtotal &lt;= (n - level) * crest || subtotal &lt;= (n - level) * trough) return true; &#125; else if(subtotal === 0) return true; else return false; &#125; // 生成组合树 while(level &lt; n) &#123; let newLeaves = []; // 存储最新叶子 leaves.forEach(node =&gt; &#123; for(let count = -trough; count &lt;= crest; ++count) &#123; let subtotal = node.subtotal + count; isOK(subtotal) &amp;&amp; newLeaves.push( &#123;parent: node, count: count, subtotal: subtotal&#125; ); &#125; &#125;); leaves = newLeaves, ++level; &#125; // 随机取一片叶子 let leaf = leaves[Math.random() * leaves.length &gt;&gt; 0]; let group = [leaf.count]; for(let i = 0; i &lt; 4; ++i) &#123; leaf = leaf.parent; group.push(leaf.count); &#125; return group; &#125; 穷举法的局限： 「无穷集合」不适用 穷举算法效率低下 由于「穷举法」的这两个致命限制，所以它不是适用于业务。事实上，笔者主要是使用「穷举法」校验「快速分配」方案的全面性。 快速分配「快速分配」方案的思路： 获取可分配波动范围； 在波动范围内随机取值 代码的实现过程如下：123456789101112131415161718192021222324252627282930313233343536function quickWave(n = 5, crest = 4, trough = 4, isInteger = true) &#123; let list = []; // 无法进行波动均分，直接返回完全平分 if(crest &gt; (n - 1) * trough || trough &gt; (n - 1) * crest) &#123; return new Array(n).fill(0); &#125; let base = 0; // 最少需要消除的高度 let wave = 0; // 波动量 let high = crest; // 高位 let low = -trough; // 低位 let sum = 0; // 累计量 let count = n; // 剩余数量 while(--count &gt;= 0) &#123; // 动态当前的波动量 if(crest &gt; count * trough - sum) &#123; high = count * trough - sum; &#125; if(trough &gt; count * crest + sum) &#123; low = -sum - count * crest; &#125; base = low; wave = high - low; let rnd; // 随机波动量 if(count &gt; 0) &#123; rnd = base + Math.random() * (wave + 1); // 随机波动 &#125; else &#123; rnd = -sum; &#125; if(isInteger === true) &#123; rnd = Math.floor(rnd); &#125; sum += rnd; list.push(rnd); &#125; return list; &#125; 波动均分的「快速分配」方案在算法效率上是高效的，并且「快速分配」适用于「无穷集合」。 如何使用「穷举法」校验「快速分配」的全面性？「穷举法」能直接返回分配组合的总数，而「快速分配」只能随机返回一次组合，笔者是通过大数量地调用「快速分配」算法并累积不重复组合来验证「快速分配」的全面性。代码如下： 1234567console.log(exhaustWave(5, 4, 4)); // 组合总数: 3951let res = &#123;&#125;, count = 0, len = 10000; for(let i = 0; i &lt; len; ++i) &#123; let name = quickWave(5, 4, 4).join(\"_\"); res[name] !== true &amp;&amp; (res[name] = true, ++count); &#125;console.log(count); // len次快速分配后的组合总数 通过调整变量 len 可以发现，当 len 越来越大输出的结果就越逼近 3951，当到达一定量级后，输出的结果就是 3951。 结语可能网上有类似的算法存在，不过笔者学识太浅没有找到对应的算法，所以自己生造了这个算法，如果有何不妥之处欢迎指正。 如果对「H5游戏开发」感兴趣，欢迎关注我们的专栏。","pubDate":"Thu, 11 Jan 2018 03:49:03 GMT","guid":"https://aotu.io/notes/2018/01/11/waveaverage/","category":"Web开发"},{"title":"H5游戏开发：套圈圈","link":"https://aotu.io/notes/2018/01/04/waterful/","description":"前言虽然本文标题为介绍一个水压套圈h5游戏，但是窃以为仅仅如此对读者是没什么帮助的，毕竟读者们的工作生活很少会再写一个类似的游戏，更多的是面对需求的挑战。我更希望能举一反三，给大家在编写h5游戏上带来一些启发，无论是从整体流程的把控，对游戏框架、物理引擎的熟悉程度还是在某一个小难点上的思路突破等。因此本文将很少详细列举实现代码，取而代之的是以伪代码展现思路为主。 游戏 demo 地址：http://jdc.jd.com/fd/demo/waterful/game.html 希望能给诸位读者带来的启发 技术选型 整体代码布局 难点及解决思路 优化点 技术选型一个项目用什么技术来实现，权衡的因素有许多。其中时间是必须优先考虑的，毕竟效果可以减，但上线时间是死的。 本项目预研时间一周，真正排期时间只有两周。虽然由项目特点来看比较适合走 3D 方案，但时间明显是不够的。最后保守起见，决定采用 2D 方案尽量逼近真实立体的游戏效果。 从游戏复杂度来考虑，无须用到 Egret 或 Cocos 这些“牛刀”，而轻量、易上手、团队内部也有深厚沉淀的 CreateJS 则成为了渲染框架的首选。 另外需要考虑的是是否需要引入物理引擎，这点需要从游戏的特点去考虑。本游戏涉及重力、碰撞、施力等因素，引入物理引擎对开发效率的提高要大于学习使用物理引擎的成本。因此权衡再三，我引入了同事们已经玩得挺溜的 Matter.js。（ Matter.js 文档清晰、案例丰富，是切入学习 web 游戏引擎的一个不错的框架） 整体代码布局在代码组织上，我选择了面向对象的手法，对整个游戏做一个封装，抛出一些控制接口给其他逻辑层调用。 伪代码： 1234&lt;!-- index.html --&gt;&lt;!-- 游戏入口 canvas --&gt;&lt;canvas id=\"waterfulGameCanvas\" width=\"660\" height=\"570\"&gt;&lt;/canvas&gt; 123456789101112131415161718192021222324252627282930313233343536// game.js/** * 游戏对象 */class Waterful &#123; // 初始化函数 init () &#123;&#125; // CreateJS Tick，游戏操作等事件的绑定放到游戏对象内 eventBinding () &#123;&#125; // 暴露的一些方法 score () &#123;&#125; restart () &#123;&#125; pause () &#123;&#125; resume () &#123;&#125; // 技能 skillX () &#123;&#125;&#125;/** * 环对象 */class Ring &#123; // 于每一个 CreateJS Tick 都调用环自身的 update 函数 update () &#123;&#125; // 进针后的逻辑 afterCollision () &#123;&#125;&#125; 12345// main.js// 根据业务逻辑初始化游戏，调用游戏的各种接口const waterful = new Waterful()waterful.init(&#123;...&#125;) 初始化游戏的初始化接口主要做了4件事情： 参数初始化 CreateJS 显示元素（display object）的布局 Matter.js 刚体（rigid body）的布局 事件的绑定 下面主要聊聊游戏场景里各种元素的创建与布局，即第二、第三点。 一、CreateJS 结合 Matter.js阅读 Matter.js 的 demo 案例，都是用其自带的渲染引擎 Matter.Render。但是由于某些原因（后面会说到），我们需要使用 CreateJS 去渲染每个环的贴图。 不像 Laya 配有和 Matter.js 自身用法一致的 Render，CreateJS 需要单独创建一个贴图层，然后在每个 Tick 里把贴图层的坐标同步为 Matter.js 刚体的当前坐标。 伪代码： 123createjs.Ticker.addEventListener('tick', e =&gt; &#123; 环贴图的坐标 = 环刚体的坐标&#125;) 使用 CreateJS 去渲染后，要单独调试 Matter.js 的刚体是非常不便的。建议写一个调试模式专门使用 Matter.js 的 Render 去渲染，以便跟踪刚体的运动轨迹。 二、环本游戏的难点是要以 2D 去模拟 3D，环是一点，进针的效果是一点，先说环。 环由一个圆形的刚体，和半径稍大一些的贴图层所组成。如下图，蓝色部分为刚体： 伪代码： 12345678class Ring &#123; constructor () &#123; // 贴图 this.texture = new createjs.Sprite(...) // 刚体 this.body = Matter.Bodies.circle(...) &#125;&#125; 三、刚体为什么把刚体半径做得稍小呢，这也是受这篇文章 推金币 里金币的做法所启发。推金币游戏中，为了达到金币间的堆叠效果，作者很聪明地把刚体做得比贴图小，这样当刚体挤在一起时，贴图间就会层叠起来。所以这样做是为了使环之间稍微有点重叠效果，更重要的也是当两个紧贴的环不会因翻转角度太接近而显得留白太多。如图： 为了模拟环在水中运动的效果，可以选择给环加一些空气摩擦力。另外在实物游戏里，环是塑料做成的，碰撞后动能消耗较大，因此可以把环的 restitution 值调得稍微小一些。 需要注意 Matter.js 中因为各种物理参数都是没有单位的，一些物理公式很可能用不上，只能基于其默认值慢慢进行微调。下面的 frictionAir 和 restitution 值就是我慢慢凭感觉调整出来的： 1234this.body = Matter.Bodies.circle(x, y, r, &#123; frictionAir: 0.02, restitution: 0.15&#125;) 四、贴图环在现实世界中的旋转是三维的，而 CreateJS 只能控制元素在二维平面上的旋转。对于一个环来说，二维平面的旋转是没有任何意义的，无论如何旋转，都只会是同一个样子。 想要达到环绕 x 轴旋转的效果，一开始想到的是使用 rotation + scaleY。虽然这样能在视觉上达到目的，但是 scaleY 会导致环有被压扁的感觉，图片会失真： 显然这样的效果是不能接受的，最后我采取了逐帧图的方式，最接近地还原了环的旋转姿态： 注意在每个 Tick 里需要去判断环是否静止，若非静止则继续播放，并将贴图的 rotation 值赋值为刚体的旋转角度。如果是停止状态，则暂停逐帧图的播放： 123456789101112131415// 贴图与刚体位置的小数点后几位有点不一样，需要降低精度const x1 = Math.round(texture.x)const x2 = Math.round(body.position.x)const y1 = Math.round(texture.y)const y2 = Math.round(body.position.y)if (x1 !== x2 || y1 !== y2) &#123; texture.paused &amp;&amp; texture.play() texture.rotation = body.angle * 180 / Math.PI&#125; else &#123; !texture.paused &amp;&amp; texture.stop()&#125; texture.x = body.position.xtexture.y = body.position.y 五、舞台舞台需要主要由物理世界、背景图，墙壁，针所组成。 1. 物理世界为了模拟真实世界环在水中的向下加速度，可以把 y 方向的 g 值调小： 1engine.world.gravity.y = 0.2 左右重力感应对环的加速度影响同样可以通过改变 x 方向的 g 值达到： 12345678// 最大倾斜角度为 70 度，让用户不需要过分倾斜手机// 0.4 为灵敏度值，根据具体情况调整window.addEventListener('deviceorientation', e =&gt; &#123; let gamma = e.gamma if (gamma &lt; -70) gamma = -70 if (gamma &gt; 70) gamma = 70 this.engine.world.gravity.x = (e.gamma / 70) * 0.4&#125;) 2. 背景图本游戏布景为游戏机及海底世界，两者可以作为父容器的背景图，把 canvas 的位置定位到游戏机内即可。canvas 覆盖范围为下图的蓝色蒙层： 3. 墙壁因为环的刚体半径比贴图半径小，因此墙壁刚体需要有一些提前位移，环贴图才不会溢出，位移量为 R - r（下图红线为墙壁刚体的一部分）： 4. 针为了模拟针的边缘轮廓，针的刚体由一个矩形与一个圆形所组成。下图红线描绘了针的刚体： 为什么针边缘没有像墙壁一样有一些提前量呢？这是因为进针效果要求针顶的平台区域尽量地窄。作为补偿，可以把环刚体的半径尽可能地调得更大，这样在视觉上环与针的重叠也就不那么明显了。 进针进针是整个游戏的核心部分，也是最难模拟的地方。 进针后两个二维平面的物体交错是不能产生“穿过”效果的： 除非把环分成前后两部分，这样层级关系才能得到解决。但是由于环贴图是逐帧图，分两部分的做法并不合适。 最后找到的解决办法是利用视觉错位来达到“穿过”效果： 具体做法是，当环被判定成功进针时，把环刚体去掉，环的逐帧图逐渐播放到平放的那一帧，rotation 值也逐渐变为 0。同时利用 CreateJS 的 Tween 动画把环平移到针底。 进针后需要去掉环刚体，平移环贴图，这就是上文为什么环的贴图必须由 CreateJS 负责渲染的答案。 伪代码： 123456789101112131415161718192021222324252627282930313233343536373839404142// Object RingafterCollision (waterful) &#123; // 平移到针底部 createjs.Tween.get(this.texture) .to(&#123;y: y&#125;, duration) // 消去刚体 Matter.World.remove(waterful.engine.world, this.body) this.body = null // 接下来每一 Tick 的更新逻辑改变如下 this.update = function () &#123; const texture = this.texture if 当前环贴图就是第 0 帧（环平放的那一帧）&#123; texture.gotoAndStop(0) &#125; else &#123; 每 5 个 Tick 往前播放一帧（相隔多少 Tick 切换一帧可以凭感觉调整，主要是为了使切换到平放状态的过程不显得太突兀） &#125; // 使针大概在环中央位置穿过 if (texture.x &lt; 200) ++texture.x if (texture.x &gt; 213 &amp;&amp; texture.x &lt; 300) --texture.x if (texture.x &gt; 462) --texture.x if (texture.x &gt; 400 &amp;&amp; texture.x &lt; 448) ++texture.x // 把环贴图尽快旋转到水平状态 let rotation = Math.round(texture.rotation) % 180 if (rotation &lt; 0) rotation += 180 if (rotation &gt; 0 &amp;&amp; rotation &lt;= 90) &#123; texture.rotation = rotation - 1 &#125; else if (rotation &gt; 90 &amp;&amp; rotation &lt; 180) &#123; texture.rotation = rotation + 1 &#125; else if (frame === 0) &#123; this.update = function () &#123;&#125; &#125; &#125; // 调用得分回调函数 waterful.score()&#125; 进针判断进针条件1. 到达针顶到达针顶是环进针成功的必要条件。 2. 动画帧环必须垂直于针才能被顺利穿过，水平于针时应该是与针相碰后弹开。 当然条件可以相对放宽一些，不需要完全垂直，下图红框内的6帧都被规定为符合条件： 为了降低游戏难度，我规定超过针一半高度时，只循环播放前6帧： 1234567this.texture.on('animationend', e =&gt; &#123; if (e.target.y &lt; 400) &#123; e.target.gotoAndPlay('short') &#125; else &#123; e.target.gotoAndPlay('normal') &#125;&#125;) 3. rotation 值同理，为了使得环与针相垂直，rotation 值不能太接近 90 度。经试验后规定 0 &lt;= rotation &lt;= 65 或 115 &lt;= rotation &lt;= 180 是进针的必要条件。 下图这种过大的倾角逻辑上是不能进针成功的： 初探一开始我想的是把三维的进针做成二维的“圆球进桶”，进针的判断也就归到物理事件上面去，不需要再去考虑。 具体做法如下图，红线为针壁，当环刚体（蓝球）掉入桶内且与 Sensor （绿线）相碰，则判断进针成功。为了使游戏难度不至于太大，环刚体必须设置得较小，而且针壁间距离要比环刚体直径稍大。 这种模拟其实已经能达到不错的效果了，但是一个技能打破了这种思路的可能性。 产品那边想做一个放大技能，当用户使用此技能时环会放大，更容易套中。但是在桶口直径不变的情况下，只是环贴图变大并不能降低游戏难度。如果把环刚体变小，的确容易进了，但相近的环之间的贴图重叠范围会很大，这就显得很不合理了。 改进“进桶”的思路走不通是因为不兼容放大技能，而放大技能改变的是环的直径。因此需要找到一种进针判断方法在环直径小时，进针难度大，直径大时，进针难度小。 下面两图分别为普通环和放大环，其中红色虚线表示水平方向的内环直径： 在针顶设置一小段探测线（下图红色虚线），当内环的水平直径与探测线相交时，证明进针成功，然后走进针后的逻辑。在环放大时，内环的水平直径变长，也就更容易与探测线相交。 伪代码： 123456789101112131415161718192021222324252627282930313233343536// Object Ring// 每一 Tick 都去判断每个运动中的环是否与探测线相交update (waterful) &#123; const texture = this.texture // 环当前中心点坐标 const x0 = texture.x const y0 = texture.y // 环的旋转弧度 const angle = texture.rotation // 内环半径 const r = waterful.enlarging ? 16 * 1.5 : 16 // 根据旋转角度算出内环水平直径的开始和结束坐标 // 注意 Matter.js 拿到的是 rotation 值是弧度，需要转成角度 const startPoint = &#123; x: x0 - r * Math.cos(angle * (Math.PI / 180)), y: y0 - r * Math.sin(angle * (Math.PI / 180)) &#125; const endPoint = &#123; x: x0 + r * Math.cos(-angle * (Math.PI / 180)), y: y0 + r * Math.sin(angle * (Math.PI / 180)) &#125; // mn 为左侧探测线段的两点，uv 为右侧探测线段的两点 const m = &#123;x: 206, y: 216&#125;, n = &#123;x: 206, y: 400&#125;, u = &#123;x: 455, y: 216&#125;, v = &#123;x: 455, y: 400&#125; if (segmentsIntr(startPoint, endPoint, m, n) || segmentsIntr(startPoint, endPoint, u, v)) &#123; // 内环直径与 mn 或 uv 相交，证明进针成功 this.afterCollision(waterful) &#125; ...&#125; 判断线段是否相交的算法可以参考这篇文章：谈谈”求线段交点”的几种算法 这种思路有两个不合常理的点： 1.当环在针顶平台直到静止时，内环水平直径都没有和探测线相交，或者相交了但是 rotation 值不符合进针要求，视觉上给人的感受就是环在针顶上静止了： 解决思路一是通过重力感应，因为设置了重力感应，只要用户稍微动一下手机环就会动起来。二是判断环刚体在针顶平台完全静止了，则给它施加一个力，让它往下掉。 2.有可能环的运动轨迹是在针顶划过，但与探测线相交了，此时会给玩家一种环被吸下来的感觉。可以通过适当设置探测线的长度来减少这种情况发生的几率。 优化资源池资源回收复用，是游戏常用的优化手法，接下来通过讲解气泡动画的实现来简单介绍一下。 气泡动画是逐帧图，用户点击按钮时，即创建一个 createjs.Sprite。在 animationend 时，把该 sprite 对象从 createjs.Stage 中 remove 掉。 可想而知，当用户不停点击时，会不断的创建 createjs.Sprite 对象，非常耗费资源。如果能复用之前播放完被 remove 掉的 sprite 对象，就能解决此问题。 具体做法是每当用户按下按钮时，先去资源池数组找有没有 sprite 对象。如果没有则创建，animationend 时把 sprite 对象从 stage 里 remove 掉，然后 push 进资源池。如果有，则从资源池取出并直接使用该对象。 当然用户的点击操作事件需要节流处理，例如至少 300ms 后才能播放下一个气泡动画。 伪代码： 123456789101112131415// Object WaterfulgetBubble = throttle(function () &#123; // 存在空闲泡泡即返回 if (this._idleBubbles.length) return this._idleBubbles.shift() // 不存在则创建 const bubble = new createjs.Sprite(...) bubble.on('animationend', () =&gt; &#123; this._stage.removeChild(bubble) this._idleBubbles.push(bubble) &#125;) return bubble&#125;, 300) 环速度过快导致飞出边界Matter.js 里由于没有实现持续碰撞检测算法（CCD），所以在物体速度过快的情况下，和其他物体的碰撞不会被检测出来。当环速度很快时，也就会出现飞出墙壁的 bug。 正常情况下，每次按键给环施加的力都是很小的。当用户快速连续点击时，y 方向累积的力也不至于过大。但还是有玩家反应游戏过程中环不见了的问题。最后发现当手机卡顿时，Matter.js 的 Tick 没有及时触发，导致卡顿完后把卡顿时累积起来的力一次性应用到环刚体上，环瞬间获得很大的速度，也就飞出了游戏场景。 解决方法有两个： 给按钮节流，300ms才能施加一次力。 每次按下按钮，只是把一个标志位设为 true。在每个 Matter.js 的 Tick 里判断该标志位是否为 true，是则施力。保证每个 Matter.js 的 Tick 里只对环施加一次力。 伪代码： 1234567891011121314btn.addEventListener('touchstart', e =&gt; &#123; this.addForce = true&#125;)Events.on(this._engine, 'beforeUpdate', e =&gt; &#123; if (!this.addForce) return this.addForceLeft = false // 施力 this._rings.forEach(ring =&gt; &#123; Matter.Body.applyForce(ring.body, &#123;x: x, y: y&#125;, &#123;x: 0.02, y: -0.03&#125;) Matter.Body.setAngularVelocity(ring.body, Math.PI/24) &#125;)&#125;) 结语如果对「H5游戏开发」感兴趣，欢迎关注我们的专栏","pubDate":"Thu, 04 Jan 2018 07:27:00 GMT","guid":"https://aotu.io/notes/2018/01/04/waterful/","category":"H5游戏开发"},{"title":"H5游戏开发：游戏引擎入门推荐","link":"https://aotu.io/notes/2017/12/27/h5-game-engine-recommend/","description":"前言很多刚刚接触到游戏开发，准备大展拳脚的小鲜肉们，往往在技术选型这第一关就栽了跟头。毕竟网络上的游戏引擎良莠不齐，官网上相关资料也比较少，而选择一个适合的游戏引擎是一个项目最基础，也是很核心的一部分。试想一下，在游戏开发进行到中后期的时候，才发现项目引入的游戏引擎与需求相悖，这时候不管是重新做一些修修补补的工作或者更换游戏引擎，这都是相当耗费人力物力的一件事。为了避免这种情况的出现，在前期选择适合项目需求的游戏引擎显得尤为重要。接下来我们来聊一聊如何去选择适合项目的 JS 游戏引擎。 游戏场景分类在刚接到游戏需求时，我们可以从以下几个方面进行考量，分析出游戏需求场景所属，从而作为我们选择游戏引擎的依据。 游戏效果呈现方式（ 2D ？ 3D ？ VR ？）这与游戏引擎能够支持的渲染方式直接挂钩。现在的 H5 游戏渲染方式一般有 2D 渲染、3D 渲染、VR 渲染三种。而 2D 渲染一般也有三种：Dom 渲染、Canvas 渲染、WebGL 渲染。Dom 由于性能原因，一般只适合做一些动画效果较少，交互较少的小游戏，本文主要针对 Canvas 和 WebGL 展开介绍。一般来说，对于 2D 小游戏来说，Canvas 渲染已经足够。然而 Canvas 渲染由于底层封装层次多，不足以支撑起大型游戏的性能要求，因此大型游戏最好选择 WebGL 渲染或者浏览器内嵌 Runtime 。 游戏复杂度这与游戏引擎能够支持的功能，提供的API，性能等方面关系比较大。 游戏引擎推荐笔者从业界较流行的一些框架，进行以下几个方面对比，希望能从客观数据上给大家的技术选型带来建议和参考。 引擎支持的渲染方式 github上的 star 数 更新时间 文档详细度 周边产品 2D，3D，VR 都支持的游戏引擎 name2D渲染（Canvas）2D渲染(WebGL)3D渲染（WebGL）VRgithub star 数文档详细程度周边产品备注EgretYESYESYESYES2k（最新更新2017.12）▪ 有中文文档▪ 例子充足▪ 社区活跃游戏开发过程中的每个环节基本都有工具支撑。不仅仅提供了一个基于HTML5技术的游戏引擎，更是提供了原生打包工具和众多周边产品LayaAirYESYES（优先）YESYES0.7k（最新更新2017.12）▪ 有中文文档▪ 例子充足▪ 社区活跃提供开发工具和可视化编辑器支持2D、3D、VR，能开发超大游戏，forgame的醉西游，腾讯的QQ农场，乐动卓越的浪漫h5这些大作就是用它开发 Egret Egret 周边产品 白鹭引擎是企业级游戏引擎，有团队维护。Egret 在工作流的支持上做的是比较好的，从 Wing 的代码编写，到 ResDepot 和 TextureMerger 的资源整合，再到 Inspector 调试，最后到原生打包（支持 APP 打包），游戏开发过程中的每个环节基本都有工具支撑。官网上的示例，教程也是比较多。值得一提的是，今年5月白鹭引擎支持了 WebAssembly ，这对于性能的提升又是一大里程碑。 LayaAir在渲染模式上，LayaAir 支持 Canvas 和 WebGL 两种方式；在工具流的支持程度上，主要是提供了 LayaAir IDE。LayaAir IDE 包括代码模式与设计模式，支持代码开发与美术设计分离，内置了 SWF 转换、图集打包、JS 压缩与加密、APP 打包、Flash 发布等实用功能。 下图是主要支持2D游戏的游戏引擎 name2D渲染（Canvas）2D渲染(WebGL)3D渲染（WebGL）VRgithub star 数文档详细程度周边产品备注Pixi.jsYESYESNONO16.8k(最新更新2017.12)▪ 英文文档▪ 例子充足▪ 英文社区无依赖于canvas的WebGL渲染器PhaserYESYESNONO16.9k（最新更2017.07）▪ 英文文档▪ 例子充足▪ 英文社区提供在线编辑器Phaser SandboxCreateJsYESYESNONO6.5k（最新更新2017.12）▪ 英文文档▪ 例子充足▪ 有博客无官方推荐TweenJS，SoundJS，PreloadJS配合使用HiloYESYESYES(Hilo3D)NO4.2k（最新更新2017.12）▪ 有中文文档▪ 例子充足提供资源下载和管理工具阿里巴巴集团推出，适合开发营销小游戏，以Chipmunk为2D物理引擎，与主流物理引擎兼容Cocos2d-xYESYESNONO11.2k（最新更新2017.12）▪ 有中文文档▪ js例子不多，c++例子较多▪ 社区活跃Cocos Creator编辑器，打包工具等提供的功能相当完整lufylegend.jsYESNONONO0.4k（最新更新2016.03）▪ 有中文文档▪ 社区活跃无仿ActionScript3.0的语法，支持Google Chrome，Firefox，Opera，IE9，IOS，Android等多种热门环境，可以配合Box2dWeb制作物理游戏，内置了LTweenLite缓动类等 Pixi.js一般来说，WebGL 的渲染速度都会比 Canvas 快，这是由俩者的绘制路径决定的。Pixi 最大的特点在于，Pixi 具有完整的 WebGL 支持，却并不要求开发者掌握 WebGL 的相关知识，并在需要时无缝地回退到 Canvas 。相较于很多同类产品，它的渲染能力是比较强大的。然而，Pixi 也有不足的地方，Pixi 对于动画的支持是比较缺乏的，在实际开发中，常常需要引进额外的动画库，如 GSAP。 PhaserPhaser 在渲染方面直接封装了 Pixi；架构方面，Phaser 内嵌了3个物理引擎（Arcade Physics、Ninja、p2.js），提供粒子系统、动画、预下载和设备适配方案；兼容性方面，Phaser 的焦点是放在移动端浏览器上的；API 方面，Phaser 能实现丰富的游戏功能，适合复杂度高的游戏开发。 CreateJS CreateJs 周边产品 CreateJS 官方提供了 TweenJS 支持动画开发，同时通过 SoundJS 和 PreLoadJS 提供了音频和预下载的支持，对于 H5 游戏基础功能的支持是足够的。在兼容性方面，CreateJS 支持 PC 端和移动端几乎所有的浏览器。此外，CreateJS 还支持用 flash CC 开发导出由 CreateJS 渲染的 H5 游戏。 HiloHilo 是阿里团队推出的一个开源项目，支持模块化开发，同时提供了多种模块范式的包装版本和跨终端解决方案，适合用来开发营销小游戏。其体积也是比较轻量的，只有70kb左右。Hilo 支持 DOM 渲染，Canvas 渲染和 WebGL 渲染，同时集成了 Hilo Audio， Hilo Preload。其后推出的 Hilo 3D 也是其亮点之一。 Cocos2d-xCocos2d-x 是业界比较老牌的游戏引擎了，同时支持 C++ ，Lua 和 JavaScript 三种开发语言，官方用例来看更倾向于 C++ 开发，适合做一些中大型游戏开发。Cocos2d-x 提供 Cocos Creator 游戏开发工具，组件化，脚本化，数据驱动，跨平台发布。 lufylegend.jslufylegend.js 的最新更新是在16年，不过其社区还是十分活跃的，如果遇到什么开发问题，可以很方便地在社区上找到解决的方案。lufylegend.js 可以支持基础的游戏功能，但是其可拓展性不是很强。 主要支持3D游戏的游戏引擎 name2D渲染（Canvas）2D渲染(WebGL)3D渲染（WebGL）VRgithub star 数文档详细程度周边产品备注Three.jsNONOYES（倾向）NO37.6k（最新更新2017.12）▪ 英文文档▪ 例子充足▪ 英文社区无默认Ammo.js为默认物理引擎，基于JavaScript语言的3D库，耗性能，加载慢，效果一般PlayCanvasNONOYESYES3k（最新更新2017.12）▪ 英文文档▪ 例子充足▪ 英文社区提供了在线编辑器，发布托管等教程较为详细，入门快 Three.js Three.js 示例案例 相信对于很多有关注 3D 游戏的开发者来说，Three.js 早已经耳熟能详了。实际上，Three.js 官方定位并不是游戏引擎，而是一个 JS 3D 库。Three.js 更倾向于展示型的视觉呈现，比较少直接拿 Three.js 来开发 H5 游戏。渲染环境上，Three.js 支持 WebGL 和 CSS3D 两种渲染模式。 PlayCanvas从渲染支持程度来看，PlayCanvas 不仅支持 3D WebGL渲染，同时保持到 VR 的支持，拥有比较好的拓展性。在工具流的支持上，提供了在线编辑器和发布托管等服务。从官方教程上看，教程也是比较详细的。 结语现在市场上的 H5游戏引擎很多，很难去直接定义哪个引擎的好坏，只能说每个引擎都有自己的特性，在某方面跟项目的契合程度比较高，笔者根据现在市场上比较热门的几大引擎做了几点比较，希望能给刚入门的你做技术选型的时候有一点帮助，找到适合项目的引擎，更快、更准、更高效率地完成项目需求。 感谢各位耐心读完，希望能有所收获，有考虑不足的地方欢迎留言指出。 如果对「H5游戏开发」感兴趣，欢迎关注我们的专栏。 参考资料目前有哪些比较成熟的 HTML5 游戏引擎？ HTML5游戏引擎深度测评 现在 TypeScript 的生态如何？","pubDate":"Wed, 27 Dec 2017 03:20:35 GMT","guid":"https://aotu.io/notes/2017/12/27/h5-game-engine-recommend/","category":"H5游戏开发"},{"title":"GraphQL 使用介绍","link":"https://aotu.io/notes/2017/12/15/graphql-use/","description":"GraphQL 是 Fackbook 的一个开源项目，它定义了一种查询语言，用于描述客户端与服务端交互时的数据模型和功能，相比 RESTful API 主要有以下特点： 根据需要返回数据 一个请求获取多个资源 提供内省系统 这使得客户端的功能得到了加强，特别是在查询数据方面。 下面我们\u0006从使用的角度来介绍一下。 相关概念在使用 GraphQL 之前，先介绍几个相关概念，便于理解使用。 Operations GraphQL 服务提供的操作一般有：query、mutation。query 可以理解为 RESTful API 中的 GET 的请求。mutation 可以理解为 RESTful API 中的 POST、PUT、DELETE 之类的请求。 Types 定义了 GraphQL 服务支持的类型，例如： 12345678type User &#123; id: ID name: String&#125;type Query &#123; user: User&#125; 定义了 User 类型和包含的字段以及字段的类型；定义 Query 返回一个 User 类型的 user，Query 也是一种类型。 Scalar types 标量类型。GraphQL 默认提供的标量类型有：Int、Float、String、Boolean、ID，也可以实现自定义的标量类型，如：Date。 标量类型有什么用呢？返回数据的字段必须是标量类型。例如我们想返回一个 user： 123query &#123; user // 报错&#125; 上面这样是会报错的，因为 user 不是标量类型，需要改成 123456query &#123; user &#123; id name &#125;&#125; 指定返回 user 的 id 和 name，这两个字段都是标量类型，就可以正确返回了。 开始使用如果看完上面的介绍，心中有很多疑问，没关系，我们现在以 GitHub GraphQL API 为例，来实际使用一下。打开 https://developer.github.com/v4/explorer/，然后登录，会看到一个这样的界面 这是 GraphQL 提供的开发工具 GraphiQL，可以检查 GraphQL 的语法，发送 GraphQL 的请求，还提供文档查询功能。在开始使用之前先介绍一下文档查询功能。点击右上角的 &lt; Docs 并可以看到 上面的 ROOT TYPES 表示最顶层支持的类型，只有两个 Query 和 Mutation。点击 Query，可以看到该类型包含的字段。仔细看，会发现这些字段的值又都是类型。 往下滚动，找到 user(login: String!): User，点击 User 终于找到一个标量类型的字段 bio: String，按照之前说法，我们是可以查询这个字段，写出如下的查询语言： 12345&#123; user &#123; bio &#125;&#125; 准备执行时，会看到 user 下方有条红线，鼠标放上去 提示 user 必须指定一个 login 的参数，再回头看文档中该字段的描述 user(login: String!): User，是不是就可以理解了，(login: ) 表示该字段接受一个 login 参数，为 String 类型，! 表示是必须的。 将查询语言改成： 12345&#123; user(login: \"booxood\") &#123; bio &#125;&#125; 再执行，并得到了我们预期指定的结果 1234567&#123; \"data\": &#123; \"user\": &#123; \"bio\": \"Happy coding &amp; Happy life\" &#125; &#125;&#125; 现在是不是有点理解这种查询语言了。下面我们再以【 Gitalk：一个基于 Github Issue 和 Preact 开发的评论插件】中的两个需求为例 展示某个 Issue 的评论和评论上的点赞数据 1234567891011121314151617181920query &#123; repository(owner: \"gitalk\", name: \"gitalk\") &#123; issue(number: 1) &#123; comments(last: 10) &#123; totalCount nodes &#123; author &#123; login avatarUrl &#125; body reactions(first: 100, content: HEART) &#123; totalCount viewerHasReacted &#125; &#125; &#125; &#125; &#125;&#125; 先通过 repository(owner: &quot;gitalk&quot;, name: &quot;gitalk&quot;) 找到 repository，再通过 issue(number: 1) 指定 issue，然后 comments(last: 10) 表示从后面取 10 条 comments，同时获取评论的 body 和 评论的 reactions(first: 100, content: HEART) 以及 reactions 的相关信息。 添加或取消某个评论上的点赞 添加 1234567mutation &#123; addReaction(input: &#123;subjectId: \"MDEyOklzc3VlQ29tbWVudDMxNTQxOTc2NQ==\", content: HEART&#125;) &#123; reaction &#123; content &#125; &#125;&#125; 取消 1234567mutation &#123; removeReaction(input: &#123;subjectId: \"MDEyOklzc3VlQ29tbWVudDMxNTQxOTc2NQ==\", content: HEART&#125;) &#123; reaction &#123; content &#125; &#125;&#125; 之前的都是查询，这两个是 mutation，分别调用了 addReaction 和 removeReaction。可以在从文档的 ROOT TYPE 上选择 Mutation 查看支持的所有 mutation。 以上主要介绍了 GraphQL 的基本使用，具体更多内容可以查看 GraphQL 提供的教程。","pubDate":"Fri, 15 Dec 2017 10:27:36 GMT","guid":"https://aotu.io/notes/2017/12/15/graphql-use/","category":"Web开发"},{"title":"H5游戏开发：指尖大冒险","link":"https://aotu.io/notes/2017/11/28/h5_game_jumping/","description":"在今年八月中旬，《指尖大冒险》SNS 游戏诞生，其具体的玩法是通过点击屏幕左右区域来控制机器人的前进方向进行跳跃，而阶梯是无穷尽的，若遇到障碍物或者是踩空、或者机器人脚下的阶砖陨落，那么游戏失败。 笔者对游戏进行了简化改造，可通过扫下面二维码进行体验。 《指尖大冒险》SNS 游戏简化版 该游戏可以被划分为三个层次，分别为景物层、阶梯层、背景层，如下图所示。 《指尖大冒险》游戏的层次划分 整个游戏主要围绕着这三个层次进行开发： 景物层：负责两侧树叶装饰的渲染，实现其无限循环滑动的动画效果。 阶梯层：负责阶梯和机器人的渲染，实现阶梯的随机生成与自动掉落阶砖、机器人的操控。 背景层：负责背景底色的渲染，对用户点击事件监听与响应，把景物层和阶梯层联动起来。 而本文主要来讲讲以下几点核心的技术内容： 无限循环滑动的实现 随机生成阶梯的实现 自动掉落阶砖的实现 下面，本文逐一进行剖析其开发思路与难点。 一、无限循环滑动的实现景物层负责两侧树叶装饰的渲染，树叶分为左右两部分，紧贴游戏容器的两侧。 在用户点击屏幕操控机器人时，两侧树叶会随着机器人前进的动作反向滑动，来营造出游戏运动的效果。并且，由于该游戏是无穷尽的，因此，需要对两侧树叶实现循环向下滑动的动画效果。 循环场景图设计要求 对于循环滑动的实现，首先要求设计提供可前后无缝衔接的场景图，并且建议其场景图高度或宽度大于游戏容器的高度或宽度，以减少重复绘制的次数。 然后按照以下步骤，我们就可以实现循环滑动： 重复绘制两次场景图，分别在定位游戏容器底部与在相对偏移量为贴图高度的上方位置。 在循环的过程中，两次贴图以相同的偏移量向下滑动。 当贴图遇到刚滑出游戏容器的循环节点时，则对贴图位置进行重置。 无限循环滑动的实现 用伪代码描述如下：12345678910111213141516// 设置循环节点transThreshold = stageHeight;// 获取滑动后的新位置，transY是滑动偏移量lastPosY1 = leafCon1.y + transY; lastPosY2 = leafCon2.y + transY;// 分别进行滑动if leafCon1.y &gt;= transThreshold // 若遇到其循环节点，leafCon1重置位置 then leafCon1.y = lastPosY2 - leafHeight; else leafCon1.y = lastPosY1;if leafCon2.y &gt;= transThreshold // 若遇到其循环节点，leafCon2重置位置 then leafCon2.y = lastPosY1 - leafHeight; else leafCon2.y = lastPosY2; 在实际实现的过程中，再对位置变化过程加入动画进行润色，无限循环滑动的动画效果就出来了。 二、随机生成阶梯的实现随机生成阶梯是游戏的最核心部分。根据游戏的需求，阶梯由「无障碍物的阶砖」和「有障碍物的阶砖」的组成，并且阶梯的生成是随机性。 无障碍阶砖的规律其中，无障碍阶砖组成一条畅通无阻的路径，虽然整个路径的走向是随机性的，但是每个阶砖之间是相对规律的。 因为，在游戏设定里，用户只能通过点击屏幕的左侧或者右侧区域来操控机器人的走向，那么下一个无障碍阶砖必然在当前阶砖的左上方或者右上方。 无障碍路径的生成规律 用 0、1 分别代表左上方和右上方，那么我们就可以建立一个无障碍阶砖集合对应的数组（下面简称无障碍数组），用于记录无障碍阶砖的方向。 而这个数组就是包含 0、1 的随机数数组。例如，如果生成如下阶梯中的无障碍路径，那么对应的随机数数组为 [0, 0, 1, 1, 0, 0, 0, 1, 1, 1]。 无障碍路径对应的 0、1 随机数 障碍阶砖的规律障碍物阶砖也是有规律而言的，如果存在障碍物阶砖，那么它只能出现在当前阶砖的下一个无障碍阶砖的反方向上。 根据游戏需求，障碍物阶砖不一定在邻近的位置上，其相对当前阶砖的距离是一个阶砖的随机倍数，距离范围为 1～3。 障碍阶砖的生成规律 同样地，我们可以用 0、1、2、3 代表其相对距离倍数，0 代表不存在障碍物阶砖，1 代表相对一个阶砖的距离，以此类推。 因此，障碍阶砖集合对应的数组就是包含 0、1、2、3 的随机数数组（下面简称障碍数组）。例如，如果生成如下图中的障碍阶砖，那么对应的随机数数组为 [0, 1, 1, 2, 0, 1, 3, 1, 0, 1]。 障碍阶砖对应的 0、1、2、3 随机数 除此之外，根据游戏需求，障碍物阶砖出现的概率是不均等的，不存在的概率为 50% ，其相对距离越远概率越小，分别为 20%、20%、10%。 利用随机算法生成随机数组根据阶梯的生成规律，我们需要建立两个数组。 对于无障碍数组来说，随机数 0、1 的出现概率是均等的，那么我们只需要利用 Math.random()来实现映射，用伪代码表示如下：1234// 生成随机数i，min &lt;= i &lt; maxfunction getRandomInt(min, max) &#123; return Math.floor(Math.random() * (max - min) + min);&#125; 12345// 生成指定长度的0、1随机数数组arr = [];for i = 0 to len arr.push(getRandomInt(0,2));return arr; 而对于障碍数组来说，随机数 0、1、2、3 的出现概率分别为：P(0)=50%、P(1)=20%、P(2)=20%、P(3)=10%，是不均等概率的，那么生成无障碍数组的办法便是不适用的。 那如何实现生成这种满足指定非均等概率分布的随机数数组呢？ 我们可以利用概率分布转化的理念，将非均等概率分布转化为均等概率分布来进行处理，做法如下： 建立一个长度为 L 的数组 A ，L 的大小从计算非均等概率的分母的最小公倍数得来。 根据非均等概率分布 P 的情况，对数组空间分配，分配空间长度为 L * Pi ，用来存储记号值 i 。 利用满足均等概率分布的随机办法随机生成随机数 s。 以随机数 s 作为数组 A 下标，可得到满足非均等概率分布 P 的随机数 A[s] ——记号值 i。 我们只要反复执行步骤 4 ，就可得到满足上述非均等概率分布情况的随机数数组——障碍数组。 结合障碍数组生成的需求，其实现步骤如下图所示。 障碍数组值随机生成过程 用伪代码表示如下：1234567891011121314151617181920// 非均等概率分布PiP = [0.5, 0.2, 0.2, 0.1]; // 获取最小公倍数L = getLCM(P); // 建立概率转化数组A = [];l = 0;for i = 0 to P.length k = L * P[i] + l while l &lt; k A[l] = i; l++;// 获取均等概率分布的随机数s = Math.floor(Math.random() * L);// 返回满足非均等概率分布的随机数return A[s]; 对这种做法进行性能分析，其生成随机数的时间复杂度为 O(1) ，但是在初始化数组 A 时可能会出现极端情况，因为其最小公倍数有可能为 100、1000 甚至是达到亿数量级，导致无论是时间上还是空间上占用都极大。 有没有办法可以进行优化这种极端的情况呢？经过研究，笔者了解到 Alias Method 算法可以解决这种情况。 Alias Method 算法有一种最优的实现方式，称为 Vose’s Alias Method ，其做法简化描述如下： 根据概率分布，以概率作为高度构造出一个高度为 1（概率为1）的矩形。 根据构造结果，推导出两个数组 Prob 数组和 Alias 数组。 在 Prob 数组中随机取其中一值 Prob[i] ，与随机生成的随机小数 k，进行比较大小。 若 k &lt;= Prob[i] ，那么输出符合期望概率分布的随机数为 i，否则输出的值是 Alias[i] 。 对障碍阶砖分布概率应用 Vose’s Alias Method 算法的数组推导过程 如果有兴趣了解具体详细的算法过程与实现原理，可以阅读 Keith Schwarz 的文章《Darts, Dice, and Coins》。 根据 Keith Schwarz 对 Vose’s Alias Method 算法的性能分析，该算法在初始化数组时的时间复杂度始终是 O(n) ，而且随机生成的时间复杂度在 O(1) ，空间复杂度也始终是 O(n) 。 两种做法的性能比较（引用 Keith Schwarz 的分析结果) 两种做法对比，明显 Vose’s Alias Method 算法性能更加稳定，更适合非均等概率分布情况复杂，游戏性能要求高的场景。 在 Github 上，@jdiscar 已经对 Vose’s Alias Method 算法进行了很好的实现，你可以到这里学习。 最后，笔者仍选择一开始的做法，而不是 Vose’s Alias Method 算法。因为考虑到在生成障碍数组的游戏需求场景下，其概率是可控的，它并不需要特别考虑概率分布极端的可能性，并且其代码实现难度低、代码量更少。 根据相对定位确定阶砖位置利用随机算法生成无障碍数组和障碍数组后，我们需要在游戏容器上进行绘制阶梯，因此我们需要确定每一块阶砖的位置。 我们知道，每一块无障碍阶砖必然在上一块阶砖的左上方或者右上方，所以，我们对无障碍阶砖的位置计算时可以依据上一块阶砖的位置进行确定。 无障碍阶砖的位置计算推导 如上图推算，除去根据设计稿测量确定第一块阶砖的位置，第n块的无障碍阶砖的位置实际上只需要两个步骤确定： 第 n 块无障碍阶砖的 x 轴位置为上一块阶砖的 x 轴位置偏移半个阶砖的宽度，若是在左上方则向左偏移，反之向右偏移。 而其 y 位置则是上一块阶砖的 y 轴位置向上偏移一个阶砖高度减去 26 像素的高度。 其用伪代码表示如下：123456// stairSerialNum代表的是在无障碍数组存储的随机方向值direction = stairSerialNum ? 1 : -1;// lastPosX、lastPosY代表上一个无障碍阶砖的x、y轴位置tmpStair.x = lastPosX + direction * (stair.width / 2);tmpStair.y = lastPosY - (stair.height - 26); 接着，我们继续根据障碍阶砖的生成规律，进行如下图所示推算。 障碍阶砖的位置计算推导 可以知道，障碍阶砖必然在无障碍阶砖的反方向上，需要进行反方向偏移。同时，若障碍阶砖的位置相距当前阶砖为 n 个阶砖位置，那么 x 轴方向上和 y 轴方向上的偏移量也相应乘以 n 倍。 其用伪代码表示如下：12345678910// 在无障碍阶砖的反方向oppoDirection = stairSerialNum ? -1 : 1;// barrSerialNum代表的是在障碍数组存储的随机相对距离n = barrSerialNum;// x轴方向上和y轴方向上的偏移量相应为n倍if barrSerialNum !== 0 // 0 代表没有 tmpBarr.x = firstPosX + oppoDirection * (stair.width / 2) * n, tmpBarr.y = firstPosY - (stair.height - 26) * n; 至此，阶梯层完成实现随机生成阶梯。 三、自动掉落阶砖的实现当游戏开始时，需要启动一个自动掉落阶砖的定时器，定时执行掉落末端阶砖的处理，同时在任务中检查是否有存在屏幕以外的处理，若有则掉落这些阶砖。 所以，除了机器人碰障碍物、走错方向踩空导致游戏失败外，若机器人脚下的阶砖陨落也将导致游戏失败。 而其处理的难点在于： 如何判断障碍阶砖是相邻的或者是在同一 y 轴方向上呢？ 如何判断阶砖在屏幕以外呢？ 掉落相邻及同一y轴方向上的障碍阶砖对于第一个问题，我们理所当然地想到从底层逻辑上的无障碍数组和障碍数组入手：判断障碍阶砖是否相邻，可以通过同一个下标位置上的障碍数组值是否为1，若为1那么该障碍阶砖与当前末端路径的阶砖相邻。 但是，以此来判断远处的障碍阶砖是否是在同一 y 轴方向上则变得很麻烦，需要对数组进行多次遍历迭代来推算。 而经过对渲染后的阶梯层观察，我们可以直接通过 y 轴位置是否相等来解决，如下图所示。 掉落相邻及同一 y 轴方向上的障碍阶砖 因为不管是来自相邻的，还是同一 y 轴方向上的无障碍阶砖，它们的 y 轴位置值与末端的阶砖是必然相等的，因为在生成的时候使用的是同一个计算公式。 处理的实现用伪代码表示如下：12345678910111213// 记录被掉落阶砖的y轴位置值thisStairY = stair.y; // 掉落该无障碍阶砖stairCon.removeChild(stair);// 掉落同一个y轴位置的障碍阶砖barrArr = barrCon.children;for i in barrArr barr = barrArr[i], thisBarrY = barr.y; if barr.y &gt;= thisStairY // 在同一个y轴位置或者低于 barrCon.removeChild(barr); 掉落屏幕以外的阶砖那对于第二个问题——判断阶砖是否在屏幕以外，是不是也可以通过比较阶砖的 y 轴位置值与屏幕底部y轴位置值的大小来解决呢？ 不是的，通过 y 轴位置来判断反而变得更加复杂。 因为在游戏中，阶梯会在机器人前进完成后会有回移的处理，以保证阶梯始终在屏幕中心呈现给用户。这会导致阶砖的 y 轴位置会发生动态变化，对判断造成影响。 但是我们根据设计稿得出，一屏幕内最多能容纳的无障碍阶砖是 9 个，那么只要把第 10 个以外的无障碍阶砖及其相邻的、同一 y 轴方向上的障碍阶砖一并移除就可以了。 掉落屏幕以外的阶砖 所以，我们把思路从视觉渲染层面再转回底层逻辑层面，通过检测无障碍数组的长度是否大于 9 进行处理即可，用伪代码表示如下：1234567891011// 掉落无障碍阶砖stair = stairArr.shift();stair &amp;&amp; _dropStair(stair);// 阶梯存在数量超过9个以上的部分进行批量掉落if stairArr.length &gt;= 9 num = stairArr.length - 9, arr = stairArr.splice(0, num); for i = 0 to arr.length _dropStair(arr[i]);&#125; 至此，两个难点都得以解决。 后言为什么笔者要选择这几点核心内容来剖析呢？因为这是我们经常在游戏开发中经常会遇到的问题： 怎样处理游戏背景循环？ 有 N 类物件，设第 i 类物件的出现概率为 P(X=i) ，如何实现产生满足这样概率分布的随机变量 X ？ 而且，对于阶梯自动掉落的技术点开发解决，也能够让我们认识到，游戏开发问题的解决可以从视觉层面以及逻辑底层两方面考虑，学会转一个角度思考，从而将问题解决简单化。 这是本文希望能够给大家在游戏开发方面带来一些启发与思考的所在。最后，还是老话，行文仓促，若错漏之处还望指正，若有更好的想法，欢迎留言交流讨论！ 另外，本文同时发布在「H5游戏开发」专栏，如果你对该方面的系列文章感兴趣，欢迎关注我们的专栏。 参考资料 《Darts, Dice, and Coins》","pubDate":"Tue, 28 Nov 2017 00:10:00 GMT","guid":"https://aotu.io/notes/2017/11/28/h5_game_jumping/","category":"H5游戏开发"},{"title":"网页适配 iPhoneX，就是这么简单","link":"https://aotu.io/notes/2017/11/27/iphonex/","description":"前言iPhoneX 取消了物理按键，改成底部小黑条，这一改动导致网页出现了比较尴尬的屏幕适配问题。对于网页而言，顶部（刘海部位）的适配问题浏览器已经做了处理，所以我们只需要关注底部与小黑条的适配问题即可（即常见的吸底导航、返回顶部等各种相对底部 fixed 定位的元素）。 笔者通过查阅了一些官方文档，以及结合实际项目中的一些处理经验，整理了一套简单的适配方案分享给大家，希望对大家有所帮助，以下是处理前后效果图： 适配之前需要了解的几个新知识安全区域安全区域指的是一个可视窗口范围，处于安全区域的内容不受圆角（corners）、齐刘海（sensor housing）、小黑条（Home Indicator）影响，如下图蓝色区域： 也就是说，我们要做好适配，必须保证页面可视、可操作区域是在安全区域内。 更详细说明，参考文档：Human Interface Guidelines - iPhoneX viewport-fitiOS11 新增特性，苹果公司为了适配 iPhoneX 对现有 viewport meta 标签的一个扩展，用于设置网页在可视窗口的布局方式，可设置三个值： contain: 可视窗口完全包含网页内容（左图） cover：网页内容完全覆盖可视窗口（右图） auto：默认值，跟 contain 表现一致 注意：网页默认不添加扩展的表现是 viewport-fit=contain，需要适配 iPhoneX 必须设置 viewport-fit=cover，这是适配的关键步骤。 更详细说明，参考文档：viewport-fit-descriptor env() 和 constant()iOS11 新增特性，Webkit 的一个 CSS 函数，用于设定安全区域与边界的距离，有四个预定义的变量： safe-area-inset-left：安全区域距离左边边界距离 safe-area-inset-right：安全区域距离右边边界距离 safe-area-inset-top：安全区域距离顶部边界距离 safe-area-inset-bottom：安全区域距离底部边界距离 这里我们只需要关注 safe-area-inset-bottom 这个变量，因为它对应的就是小黑条的高度（横竖屏时值不一样）。 注意：当 viewport-fit=contain 时 env() 是不起作用的，必须要配合 viewport-fit=cover 使用。对于不支持env() 的浏览器，浏览器将会忽略它。 在这之前，笔者使用的是 constant()，后来，官方文档加了这么一段注释（坑）： The env() function shipped in iOS 11 with the name constant(). Beginning with Safari Technology Preview 41 and the iOS 11.2 beta, constant() has been removed and replaced with env(). You can use the CSS fallback mechanism to support both versions, if necessary, but should prefer env() going forward. 这就意味着，之前使用的 constant() 在 iOS11.2 之后就不能使用的，但我们还是需要做向后兼容，像这样： 12padding-bottom: constant(safe-area-inset-bottom); /* 兼容 iOS &lt; 11.2 */padding-bottom: env(safe-area-inset-bottom); /* 兼容 iOS &gt;= 11.2 */ 注意：env() 跟 constant() 需要同时存在，而且顺序不能换。 更详细说明，参考文档：Designing Websites for iPhone X 如何适配了解了以上所说的几个知识点，接下来我们适配的思路就很清晰了。 第一步：设置网页在可视窗口的布局方式新增 viweport-fit 属性，使得页面内容完全覆盖整个窗口：1&lt;meta name=\"viewport\" content=\"width=device-width, viewport-fit=cover\"&gt; 前面也有提到过，只有设置了 viewport-fit=cover，才能使用 env()。 第二步：页面主体内容限定在安全区域内这一步根据实际页面场景选择，如果不设置这个值，可能存在小黑条遮挡页面最底部内容的情况。1234body &#123; padding-bottom: constant(safe-area-inset-bottom); padding-bottom: env(safe-area-inset-bottom);&#125; 第三步：fixed 元素的适配类型一：fixed 完全吸底元素（bottom = 0），比如下图这两种情况： 可以通过加内边距 padding 扩展高度：1234&#123; padding-bottom: constant(safe-area-inset-bottom); padding-bottom: env(safe-area-inset-bottom);&#125; 或者通过计算函数 calc 覆盖原来高度：1234&#123; height: calc(60px(假设值) + constant(safe-area-inset-bottom)); height: calc(60px(假设值) + env(safe-area-inset-bottom));&#125; 注意，这个方案需要吸底条必须是有背景色的，因为扩展的部分背景是跟随外容器的，否则出现镂空情况。 还有一种方案就是，可以通过新增一个新的元素（空的颜色块，主要用于小黑条高度的占位），然后吸底元素可以不改变高度只需要调整位置，像这样： 1234&#123; margin-bottom: constant(safe-area-inset-bottom); margin-bottom: env(safe-area-inset-bottom);&#125; 空的颜色块：12345678&#123; position: fixed; bottom: 0; width: 100%; height: constant(safe-area-inset-bottom); height: env(safe-area-inset-bottom); background-color: #fff;&#125; 类型二：fixed 非完全吸底元素（bottom ≠ 0），比如 “返回顶部”、“侧边广告” 等像这种只是位置需要对应向上调整，可以仅通过外边距 margin 来处理：1234&#123; margin-bottom: constant(safe-area-inset-bottom); margin-bottom: env(safe-area-inset-bottom);&#125; 或者，你也可以通过计算函数 calc 覆盖原来 bottom 值：1234&#123; bottom: calc(50px(假设值) + constant(safe-area-inset-bottom)); bottom: calc(50px(假设值) + env(safe-area-inset-bottom));&#125; 你也可以使用 @supports 隔离兼容样式写到这里，我们常见的两种类型的 fixed 元素适配方案已经了解了吧。如果我们只希望 iPhoneX 才需要新增适配样式，我们可以配合 @supports 来隔离兼容样式，当然这个处理对页面展示实际不会有任何影响：123456@supports (bottom: constant(safe-area-inset-bottom)) or (bottom: env(safe-area-inset-bottom)) &#123; div &#123; margin-bottom: constant(safe-area-inset-bottom); margin-bottom: env(safe-area-inset-bottom); &#125;&#125; 写在最后以上几种方案仅供参考，笔者认为，现阶段适配处理起来是有点折腾，但是至少能解决，具体需要根据页面实际场景，在不影响用户体验与操作的大前提下不断尝试与探索，才能更完美的适配。","pubDate":"Mon, 27 Nov 2017 02:00:00 GMT","guid":"https://aotu.io/notes/2017/11/27/iphonex/","category":"Web开发"},{"title":"H5游戏开发：决胜三分球","link":"https://aotu.io/notes/2017/11/16/basketball/","description":"前言本次是与腾讯手机充值合作推出的活动，用户通过氪金充值话费或者分享来获得更多的投篮机会，根据最终的进球数排名来发放奖品。 用户可以通过滑动拉出一条辅助线，根据辅助线长度和角度的不同将球投出，由于本次活动的开发周期短，在物理特性实现方面使用了物理引擎，所有本文的分享内容是如何结合物理引擎去实现一款投篮小游戏，如下图所示。 准备 此次我使用的游戏引擎是 LayaAir，你也可以根据你的爱好和实际需求选择合适的游戏引擎进行开发，为什么选择该引擎进行开发 ，总的来说有以下几个原因： LayaAir 官方文档、API、示例学习详细、友好，可快速上手 除了支持 2D 开发，同时还支持 3D 和 VR 开发，支持 AS、TS、JS 三种语言开发 在开发者社区中提出的问题，官方能及时有效的回复 提供 IDE 工具，内置功能有打包 APP、骨骼动画转换、图集打包、SWF转换、3D 转换等等 物理引擎方面采用了 Matter.js，篮球、篮网的碰撞弹跳都使用它来实现，当然，还有其他的物理引擎如 planck.js、p2.js 等等，具体没有太深入的了解，Matter.js 相比其他引擎的优势在于： 轻量级，性能不逊色于其他物理引擎 官方文档、Demo 例子非常丰富，配色有爱 API 简单易用，轻松实现弹跳、碰撞、重力、滚动等物理效果 Github Star 数处于其他物理引擎之上，更新频率更高 开始一、初始化游戏引擎首先对 LayaAir 游戏引擎进行初始化设置，Laya.init 创建一个 1334x750 的画布以 WebGL 模式去渲染，渲染模式下有 WebGL 和 Canvas，使用 WebGL 模式下会出现锯齿的问题，使用 Config.isAntialias 抗锯齿可以解决此问题，并且使用引擎中自带的多种屏幕适配 screenMode。 如果你使用的游戏引擎没有提供屏幕适配，欢迎阅读另一位同事所写的文章【H5游戏开发：横屏适配】。 12345678...Config.isAntialias = true; // 抗锯齿Laya.init(1334, 750, Laya.WebGL); // 初始化一个画布，使用 WebGL 渲染，不支持时会自动切换为 CanvasLaya.stage.alignV = 'top'; // 适配垂直对齐方式Laya.stage.alignH = 'middle'; // 适配水平对齐方式Laya.stage.screenMode = this.Stage.SCREEN_HORIZONTAL; // 始终以横屏展示Laya.stage.scaleMode = \"fixedwidth\"; // 宽度不变，高度根据屏幕比例缩放，还有 noscale、exactfit、showall、noborder、full、fixedheight 等适配模式... 二、初始化物理引擎、加入场景然后对 Matter.js 物理引擎进行初始化，Matter.Engine 模块包含了创建和处理引擎的方法，由引擎运行这个世界，engine.world 则包含了用于创建和操作世界的方法，所有的物体都需要加入到这个世界中，Matter.Render 是将实例渲染到 Canvas 中的渲染器。 enableSleeping 是开启刚体处于静止状态时切换为睡眠状态，减少物理运算提升性能，wireframes 关闭用于调试时的线框模式，再使用 LayaAir 提供的 Laya.loading、new Sprite 加载、绘制已简化的场景元素。 1234567891011121314...this.engine;var world;this.engine = Matter.Engine.create(&#123; enableSleeping: true // 开启睡眠&#125;);world = this.engine.world;Matter.Engine.run(this.engine); // Engine 启动var render = LayaRender.create(&#123; engine: this.engine, options: &#123; wireframes: false, background: \"#000\" &#125;&#125;);LayaRender.run(render); // Render 启动... 1234567...// 加入背景、篮架、篮框var bg = new this.Sprite();Laya.stage.addChild(bg);bg.pos(0, 0);bg.loadImage('images/bg.jpg');... 三、画出辅助线，计算长度、角度投球的力度和角度是根据这条辅助线的长短角度去决定的，现在我们加入手势事件 MOUSE_DOWN、MOUSE_MOVE、MOUSE_UP 画出辅助线，通过这条辅助线起点和终点的 X、Y 坐标点再结合两个公式： getRad、getDistance 计算出距离和角度。 1234567...var line = new this.Sprite();Laya.stage.addChild(line);Laya.stage.on(this.Event.MOUSE_DOWN, this, function(e) &#123; ... &#125;);Laya.stage.on(this.Event.MOUSE_MOVE, this, function(e) &#123; ... &#125;);Laya.stage.on(this.Event.MOUSE_UP, this, function(e) &#123; ... &#125;);... 12345678910111213...getRad: function(x1, y1, x2, y2) &#123; // 返回两点之间的角度 var x = x2 - x1; var y = y2 - x2; var Hypotenuse = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)); var angle = x / Hypotenuse; var rad = Math.acos(angle); if (y2 &lt; y1) &#123; rad = -rad; &#125; return rad;&#125;,getDistance: function(x1, y1, x2, y2) &#123; // 计算两点间的距离 return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));&#125;... 四、生成篮球施加力度大致初始了一个简单的场景，只有背景和篮框，接下来是加入投篮。 每次在 MOUSE_UP 事件的时候我们就生成一个圆形的刚体， isStatic: false 我们要移动所以不固定篮球，并且设置 density 密度、restitution 弹性、刚体的背景 sprite 等属性。 将获得的两个值：距离和角度，通过 applyForce 方法给生成的篮球施加一个力，使之投出去。 12345678910111213141516171819...addBall: function(x, y) &#123; var ball = Matter.Bodies.circle(500, 254, 28, &#123; // x, y, 半径 isStatic: false, // 不固定 density: 0.68, // 密度 restitution: 0.8, // 弹性 render: &#123; visible: true, // 开启渲染 sprite: &#123; texture: 'images/ball.png', // 设置为篮球图 xOffset: 28, // x 设置为中心点 yOffset: 28 // y 设置为中心点 &#125; &#125; &#125;);&#125;Matter.Body.applyForce(ball, ball.position, &#123; x: x, y: y &#125;); // 施加力Matter.World.add(this.engine.world, [ball]); // 添加到世界... 五、加入其他刚体、软体现在，已经能顺利的将篮球投出，现在我们还需要加入一个篮球网、篮框、篮架。 通过 Matter.js 加入一些刚体和软体并且赋予物理特性 firction 摩擦力、frictionAir 空气摩擦力等， visible: false 表示是否隐藏，collisionFilter 是过滤碰撞让篮球网之间不产生碰撞。 123456789101112131415161718192021222324252627282930...addBody: function() &#123; var group = Matter.Body.nextGroup(true); var netBody = Matter.Composites.softBody(1067, 164, 6, 4, 0, 0, false, 8.5, &#123; // 篮球网 firction: 1, // 摩擦力 frictionAir: 0.08, // 空气摩擦力 restitution: 0, // 弹性 render: &#123; visible: false &#125;, collisionFilter: &#123; group: group &#125; &#125;, &#123; render: &#123; lineWidth: 2, strokeStyle: \"#fff\" &#125; &#125;); netBody.bodies[0].isStatic = netBody.bodies[5].isStatic = true; // 将篮球网固定起来 var backboard = Matter.Bodies.rectangle(1208, 120, 50, 136, &#123; // 篮板刚体 isStatic: true, render: &#123; visible: true &#125; &#125;); var backboardBlock = Matter.Bodies.rectangle(1069, 173, 5, 5, &#123; // 篮框边缘块 isStatic: true, render: &#123; visible: true &#125; &#125;); Matter.World.add(this.engine.world, [ // 四周墙壁 ... Matter.Bodies.rectangle(667, 5, 1334, 10, &#123; // x, y, w, h isStatic: true &#125;), ... ]); Matter.World.add(this.engine.world, [netBody, backboard, backboardBlock]);&#125; 六、判断进球、监听睡眠状态通过开启一个 tick 事件不停的监听球在运行时的位置，当到达某个位置时判定为进球。 另外太多的篮球会影响性能，所以我们使用 sleepStart 事件监听篮球一段时间不动后，进入睡眠状态时删除。 123456789101112...Matter.Events.on(this.engine, 'tick', function() &#123; countDown++; if (ball.position.x &gt; 1054 &amp;&amp; ball.position.x &lt; 1175 &amp;&amp; ball.position.y &gt; 170 &amp;&amp; ball.position.y &lt; 180 &amp;&amp; countDown &gt; 2) &#123; countDown = 0; console.log('球进了！'); &#125;&#125;);Matter.Events.on(ball, 'sleepStart', function() &#123; Matter.World.remove(This.engine.world, ball);&#125;);... 到此为止，通过借助物理引擎所提供的碰撞、弹性、摩擦力等特性，一款简易版的投篮小游戏就完成了，也推荐大家阅读另一位同事的文章【H5游戏开发】推金币 ，使用了 CreateJS + Matter.js 的方案，相信对你仿 3D 和 Matter.js 的使用上有更深的了解。 最后，此次项目中只做了一些小尝试，Matter.js 能实现的远不止这些，移步官网发现更多的惊喜吧，文章的完整 Demo 代码可【点击这里】。 如果对「H5游戏开发」感兴趣，欢迎关注我们的专栏。 参考Matter.js LayaAir Demo","pubDate":"Thu, 16 Nov 2017 12:55:06 GMT","guid":"https://aotu.io/notes/2017/11/16/basketball/","category":"H5游戏开发"},{"title":"H5游戏开发：推金币","link":"https://aotu.io/notes/2017/11/06/coindozer/","description":"近期参与开发的一款「京东11.11推金币赢现金」（已下线）小游戏一经发布上线就在朋友圈引起大量传播。看到大家玩得不亦乐乎，同时也引发不少网友激烈讨论，有的说很带劲，有的大呼被套路被耍猴（无奈脸），这都与我的预期相去甚远。在相关业务数据呈呈上涨过程中，曾一度被微信「有关部门」盯上并要求做出调整，真是受宠若惊。接下来就跟大家分享下开发这款游戏的心路历程。 背景介绍一年一度的双十一狂欢购物节即将拉开序幕，H5 互动类小游戏作为京东微信手Q营销特色玩法，在今年预热期的第一波造势中，势必要玩点新花样，主要肩负着社交传播和发券的目的。推金币以传统街机推币机为原型，结合手机强大的能力和生态衍生出可玩性很高的玩法。 前期预研在体验过 AppStore 上好几款推金币游戏 App 后，发现游戏核心模型还是挺简单的，不过 H5 版本的实现在网上很少见。由于团队一直在做 2D 类互动小游戏，在 3D 方向暂时没有实际的项目输出，然后结合此次游戏的特点，一开始想挑战用 3D 来实现，并以此项目为突破口，跟设计师进行深度合作，抹平开发过程的各种障碍。 由于时间紧迫，需要在短时间内敲定方案可行性，否则项目延期人头不保。在快速尝试了 Three.js + Ammo.js 方案后，发现不尽人意，最终因为各方面原因放弃了 3D 方案，主要是不可控因素太多：时间上、设计及技术经验上、移动端 WebGL 性能表现上，主要还是业务上需要对游戏有绝对的控制，加上是第一次接手复杂的小游戏，担心项目无法正常上线，有点保守，此方案遂卒。 如果读者有兴趣的话可以尝试下 3D 实现，在建模方面，首推 Three.js ，入手非常简单，文档和案例也非常详实。当然入门的话必推这篇 Three.js入门指南，另外同事分享的这篇 Three.js 现学现卖 也可以看看，这里奉上粗糙的 推金币 3D 版 Demo 技术选型放弃了 3D 方案，在 2D 技术选型上就很从容了，最终确定用 CreateJS + Matter.js 组合作为渲染引擎和物理引擎，理由如下： CreateJS 在团队内用得比较多，有一定的沉淀，加上有老司机带路，一个字「稳」； Matter.js 身材纤细、文档友好，也有同事试玩过，完成需求绰绰有余。 技术实现因为是 2D 版本，所以不需要建各种模型和贴图，整个游戏场景通过 canvas 绘制，覆盖在背景图上，然后再做下机型适配问题，游戏主场景就处理得差不多了，其他跟 3D 思路差不多，核心元素包含障碍物、推板、金币、奖品和技能，接下来就分别介绍它们的实现思路。 障碍物通过审稿确定金币以及奖品的活动区域，然后把活动区域之外的区域都作为障碍物，用来限制金币的移动范围，防止金币碰撞时超出边界。这里可以用 Matter.js 的 Bodies.fromVertices 方法，通过传入边界各转角的顶点坐标一次性绘制出形状不规则的障碍物。 不过 Matter.js 在渲染不规则形状时存在问题，需要引入 poly-decomp 做兼容处理。 12345678910111213World.add(this.world, [ Bodies.fromVertices(282, 332,[ // 顶点坐标 &#123; x: 0, y: 0 &#125;, &#123; x: 0, y: 890 &#125;, &#123; x: 140, y: 815 &#125;, &#123; x: 208, y: 614 &#125;, &#123; x: 548, y: 614 &#125;, &#123; x: 612, y: 815 &#125;, &#123; x: 750, y: 890 &#125;, &#123; x: 750, y: 0 &#125; ])]); 推板 创建：\bCreateJS 根据推板图片创建 Bitmap 对象比较简单，就不详细讲解了。这里着重讲下推板刚体的创建，主要是跟推板 Bitmap 信息进行同步。因为推板视觉上表现为梯形，所以这里用的梯形刚体，实际上方形也可以，只要能跟周围障碍物形成封闭区域，防止出现缝隙卡住金币即可，创建的刚体直接挂载到推板对象上，方便后续随时提取（金币的处理也是一样），代码大致如下： 123456789var bounds = this.pusher.getBounds();this.pusher.body = Matter.Bodies.trapezoid( this.pusher.x, this.pusher.y, bounds.width, bounds.height&#125;);Matter.World.add(this.world, [this.pusher.body]); 伸缩：由于推板会沿着视线方向前后移动，为了达到近大远小效果，所以需要在推板伸长和收缩过程中进行缩放处理，这样也可以跟两侧的障碍物边沿进行贴合，让场景看起来更具真实感（伪 3D），当然金币和奖品也需要进行同样的处理。由于推板是自驱动做前后伸缩移动，所以需要对推板及其对应的刚体进行位置同步，这样才会与金币刚体产生碰撞达到推动金币的效果。同时在外部改变（伸长技能）推板最大长度时，也需要让推板保持均匀的缩放比而不至于突然放大／缩小，所以整个推板代码逻辑包含方向控制、长度控制、速度控制、缩放控制和同步控制，代码大致如下： 12345678910111213141516171819202122232425262728293031var direction, velocity, ratio, deltaY, minY = 550, maxY = 720, minScale = .74;Matter.Events.on(this.engine, 'beforeUpdate', function (event) &#123; // 长度控制（点击伸长技能时） if (this.isPusherLengthen) &#123; velocity = 90; this.pusherMaxY = maxY; &#125; else &#123; velocity = 85; this.pusherMaxY = 620; &#125; // 方向控制 if (this.pusher.y &gt;= this.pusherMaxY) &#123; direction = -1; // 移动到最大长度时结束伸长技能 this.isPusherLengthen = false; &#125; else if (this.pusher.y &lt;= this.pusherMinY) &#123; direction = 1; &#125; // 速度控制 this.pusher.y += direction * velocity; // 缩放控制，在最大长度变化时保持同样的缩放量，防止突然放大／缩小 ratio = (1 - minScale) * ((this.pusher.y - minY) / (maxY - minY)) this.pusher.scaleX = this.pusher.scaleY = minScale + ratio; // 同步控制，刚体跟推板位置同步 Body.setPosition(this.pusher.body, &#123; x: this.pusher.x, y: this.pusher.y &#125;);&#125;) 遮罩：推板伸缩实际上是通过改变坐标来达到位置上的变化，这样存在一个问题，就是在其伸缩时必然会导致缩进的部分「溢出」边界而不是被遮挡。 所以需要做遮挡处理，这里用 CreateJS 的 mask 遮罩属性可以很好的做「溢出」裁剪： 123var shape = new createjs.Shape();shape.graphics.beginFill('#ffffff').drawRect(0, 612, 750, 220);this.pusher.mask = shape 最终效果如下： 金币按正常思路，应该在点击屏幕时就在出币口创建金币刚体，让其在重力作用下自然掉落和回弹。但是在调试过程中发现，金币掉落后跟台面上其他金币产生碰撞会导致乱飞现象，甚至会卡到障碍物里面去（原因暂未知），后面改成用 TweenJS 的 Ease.bounceOut 来实现金币掉落动画，让金币掉落变得更可控，同时尽量接近自然掉落效果。这样金币从创建到消失过程就被拆分成了三个阶段： 第一阶段 点击屏幕从左右移动的出币口创建金币，然后掉落到台面。需要注意的是，由于创建金币时是通过 appendChild 方式加入到舞台的，这样金币会非常有规律的在 z 轴方向上叠加，看起来非常怪异，所以需要随机设置金币的 z-index，让金币叠加更自然，伪\b代码如下： 12var index = Utils.getRandomInt(1, Game.coinContainer.getNumChildren());Game.coinContainer.setChildIndex(this.coin, index); 第二阶段 由于金币已经不需要重力场，所以需要设置物理世界的\b重力为 0，这样金币不会因为自身重量（需要设置重量来控制碰撞时移动的速度）做自由落体运动，安安静静的平躺在台面上，等待跟推板、其他金币和障碍物之间产生碰撞： 12this.engine = Matter.Engine.create();this.engine.world.gravity.y = 0; 由于游戏主要逻辑都集中这个阶段，所以处理起来会稍微复杂些。真实情况下如果金币掉落并附着在推板上后，会跟随推板的伸缩而被带动，最终在推板缩进到最短时被背后的墙壁阻挡而挤下推板，此过程看起来简单但实现起来会非常耗时，最后因为时间上紧迫的这里也做了简化处理，就是不管推板是伸长还是缩进，都让推板上的金币向前「滑行」尽快脱离推板。一旦金币离开推板则立即为其创建同步的刚体，为后续的碰撞做准备，这样就完成了金币的碰撞处理。 12345678910111213141516171819202122232425262728293031Matter.Events.on(this.engine, 'beforeUpdate', function (event) &#123; // 处理金币与推板碰撞 for (var i = 0; i &lt; this.coins.length; i++) &#123; var coin = this.coins[i]; // 金币在推板上 if (coin.sprite.y &lt; this.pusher.y) &#123; // 无论推板伸长／缩进金币都往前移动 if (deltaY &gt; 0) &#123; coin.sprite.y += deltaY; &#125; else &#123; coin.sprite.y -= deltaY; &#125; // 金币缩放 if (coin.sprite.scaleX &lt; 1) &#123; coin.sprite.scaleX += 0.001; coin.sprite.scaleY += 0.001; &#125; &#125; else &#123; // 更新刚体坐标 if (coin.body) &#123; Matter.Body.set(coin.body, &#123; position: &#123; x: coin.sprite.x, y: coin.sprite.y &#125; &#125;) &#125; else &#123; // 金币离开推板则创建对应刚体 coin.body = Matter.Bodies.circle(coin.sprite.x, coin.sprite.y); Matter.World.add(this.world, [coin.body]); &#125; &#125; &#125;&#125;) 第三阶段 随着金币不断的投放、碰撞和移动，最终金币会从台面的下边沿掉落并消失，此阶段的处理同第一阶段，这里就不重复了。 奖品由于奖品需要根据业务情况进行控制，所以把它跟金币进行了分离不做碰撞处理（内心是拒绝的），所以产生了「螃蟹步」现象，这里就不做过多介绍了。 技能设计写好游戏主逻辑之后，技能就属于锦上添花的事情了，不过让游戏更具可玩性，想想金币哗啦啦往下掉的感觉还是很棒的。 抖动：这里取了个巧，是给舞台容器添加了 CSS3 实现的抖动效果，然后在抖动时间内让所有的金币的 y 坐标累加固定值产生整体慢慢前移效果，由于安卓下支持系统震动 API，所以加了个彩蛋让游戏体验更真实。 CSS3 抖动实现主要是参考了 csshake 这个样式，非常有意思的一组抖动动画集合。 JS 抖动 API 123456// 安卓震动if (isAndroid) &#123; window.navigator.vibrate = navigator.vibrate || navigator.webkitVibrate || navigator.mozVibrate || navigator.msVibrate; window.navigator.vibrate([100, 30, 100, 30, 100, 200, 200, 30, 200, 30, 200, 200, 100, 30, 100, 30, 100]); window.navigator.vibrate(0); // 停止抖动&#125; 伸长：伸长处理也很简单，通过改变推板移动的最大 y 坐标值让金币产生更大的移动距离，不过细节上有几点需要注意的地方，在推板最大 y 坐标值改变之后需要保持移动速度不变，不然就会产生「瞬移」(不平滑)问题。 调试方法由于用了物理引擎，当在创建刚体时需要跟 CreateJS 图形保持一致，这里可以利用 Matter.js 自带的 Render 为物理场景独立创建一个透明的渲染层，然后覆盖在 CreateJS 场景之上，这里贴出大致代码： 12345678910Matter.Render.create(&#123; element: document.getElementById('debugger-canvas'), engine: this.engine, options: &#123; width: 750, height: 1206, showVelocity: true, wireframes: false // 设置为非线框，刚体才可以渲染出颜色 &#125;&#125;); 设置刚体的 render 属性为半透明色块，方便观察和调试，这里以推板为例： 123456789this.pusher.body = Matter.Bodies.trapezoid(... // 略&#123; isStatic: true, render: &#123; opacity: .5, fillStyle: 'red' &#125;&#125;); 效果如下，调试起来还是很方便的： 性能／体验优化控制对象数量随着游戏的持续台面上累积的金币数量会不断增加，金币之间的碰撞计算量也会陡增，必然会导致手机卡顿和发热。这时就需要控制金币的重叠度，而金币之间重叠的区域大小是由金币刚体的尺寸大小决定的，通过适当的调整刚体半径让金币分布得比较均匀，这样可以有效控制金币数量，提升游戏性能。 安卓卡顿一开始是给推板一个固定的速度进行伸缩处理，发现在 iOS 上表现流畅，但是在部分安卓机上却显得差强人意。由于部分安卓机型 FPS 比较低，导致推板在单位时间内位移比较小，表现出来就显得卡顿不流畅。后面让推板位移根据刷新时间差进行递增／减，保证不同帧频机型下都能保持一致的位移，代码大致如下： 1234567var delta = 0, prevTime = 0;Matter.Events.on(this.engine, 'beforeUpdate', function (event) &#123; delta = event.timestamp - prevTime; prevTime = event.timestamp; // ... 略 this.pusher.y += direction * velocity * (delta / 1000)&#125;) 对象回收这也是游戏开发中常用的优化手段，通过回收从边界消失的对象，让对象得以复用，防止因频繁创建对象而产生大量的内存消耗。 事件销毁由于金币和奖品生命周期内使用了 Tween，当他们从屏幕上消失后记得移除掉： 1createjs.Tween.removeTweens(this.coin); 至此，推金币各个关键环节都有讲到了，最后附上一张实际游戏效果： 结语感谢各位耐心读完，希望能有所收获，有考虑不足的地方欢迎留言指出。 如果对「H5游戏开发」感兴趣，欢迎关注我们的专栏。 相关资源Three.js 官网 Three.js入门指南 Three.js 现学现卖 Matter.js 官网 Matter.js 2D 物理引擎试玩报告 .post-content img { display: block; margin: 20px auto; }","pubDate":"Mon, 06 Nov 2017 11:53:08 GMT","guid":"https://aotu.io/notes/2017/11/06/coindozer/","category":"H5游戏开发"},{"title":"H5动画：轨迹移动","link":"https://aotu.io/notes/2017/11/06/path-animation/","description":"动画，是指由许多帧静止的画面，以一定的速度（如每秒16张）连续播放时，肉眼因视觉残象产生错觉，而误以为画面活动的作品。 在 Web 开发中，经常需要实现各种动画效果，例如：移动、变形、透明度变化等，今天我们主要来讨论各种移动的实现。 直线移动 通常可以直接由各个点的位置，以及到点的时间与整个动画持续时间的比值，写出类似下面的代码并可实现动画。 12345678910.cray &#123; animation: move 2s alternate infinite;&#125;@keyframes move &#123; 0% &#123; transform: translate(0, 0); &#125; 30% &#123; transform: translate(100px, 0); &#125; 60% &#123; transform: translate(100px, 100px); &#125; 100% &#123; transform: translate(200px, 0); &#125;&#125; 曲线移动 在 CSS 中可以通过 transform-origin 配合 rotate 实现曲线移动，不过这种\b 曲线 都是圆的\b一部分且不太好控制。 这种移动我们可以把它拆分成两个方向的运动叠加，如 更详细的说明可以参考这篇文章 《curved-path-animations-in-css》。 路径移动 这也是曲线\b移动，但是想像上面那样，这个很难拆分成几个方向的运动叠加。这样的移动路径可以尝试以下几个方法： SVG Animation 这样的路径可以比较好的用 SVG path 来描述，然后使用 SVG Animation\b 做跟随动画，并可以达到预期的轨迹效果。 主要代码（在线示例）： 123456789101112131415161718&lt;svg width=\"420px\" height=\"260px\" viewBox=\"0 0 420 260\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"&gt; &lt;g stroke=\"#979797\" stroke-width=\"1\" fill=\"none\"&gt; &lt;path id=\"motionPath\" d=\"M370.378234,219.713623 C355.497359,218.517659 ...\" &gt;&lt;/path&gt; &lt;/g&gt; &lt;g id=\"cray\" transform=\"translate(0, -24)\" stroke=\"#979797\"&gt; &lt;image id=\"cray-img\" xlink:href=\"http://7xt5iu.com1.z0.glb.clouddn.com/img/cray.png\" x=\"0\" y=\"0\" width=\"100px\"/&gt; &lt;/g&gt; &lt;animateMotion xlink:href=\"#cray\" dur=\"5s\" begin=\"0s\" fill=\"freeze\" repeatCount=\"indefinite\" rotate=\"auto-reverse\" &gt; &lt;mpath xlink:href=\"#motionPath\" /&gt; &lt;/animateMotion&gt;&lt;/svg&gt; 效果： JavaScript 使用 JavaScript 可以直接操作元素进行运动，理论上可以实现任何动画，只是实现一些复杂的动画成本比较高，好在有各种已经开发好了的工具库可以供我们使用。例如，使用 Greensock 的 TweenMax 和 MorphSVGPlugin（收费），通过 MorphSVGPlugin 提供的 pathDataToBezier 方法将 \bSVG path 转成曲线数组，然后给 TweenMax 使用： 123456789101112var hill = document.getElementById('hill')var path = MorphSVGPlugin.pathDataToBezier(\"#motionPath\");TweenMax.to(hill, 5, &#123; bezier:&#123; values:path, type:\"cubic\", autoRotate: 180 &#125;, ease:Linear.easeNone, repeat: -1&#125;) 在线示例 CSS 实现动画，其实就是在相应的时间点做相应的“变化”。再回头看直线移动的实现方式，其实如果能给出足够多点的位置和该点的时间与持续时间的比值，那其实曲线也可以直接用 CSS 来实现。 很多时候设计师使用 AE 来设计动画，当我们拿到设计稿后，可以给动画增加关键帧，然后借助一些工具把关键帧的信息导出来，这里介绍一个 keyframes-cli，可以导出这样结构的数据 从属性名字可以判断出来 X_POSITION 和 Y_POSITION 是 x 和 y 的位置信息，而 key_values 里的 data 就是我们需要的点位置， 该点的时间与持续时间的比值 可以根据 start_frame 得出，写个脚本把这些数据处理下，可得到类似下面的 CSS 代码 设置的关键帧越多，动画会越流畅，但 CSS 也会增多。 注意：不是 AE 关键帧里所有的信息都可以导出来，还跟 AE 里使用的过渡属性有关，这里有介绍。 最后，总结一下，移动动画就是用一种合适的方式把时间和位置的变化关系展示出来。除了上面方法，肯定还有很多其他的方法和帮助工具，欢迎留言交流讨论。 如果对「H5游戏开发」感兴趣，欢迎关注我们的专栏。","pubDate":"Mon, 06 Nov 2017 10:27:36 GMT","guid":"https://aotu.io/notes/2017/11/06/path-animation/","category":"Web开发"},{"title":"H5游戏开发：一笔画","link":"https://aotu.io/notes/2017/11/02/onestroke/","description":"一笔画是图论科普中一个著名的问题，它起源于柯尼斯堡七桥问题科普。数学家欧拉在他1736年发表的论文《柯尼斯堡的七桥》中不仅解决了七桥问题，也提出了一笔画定理，顺带解决了一笔画问题。用图论的术语来说，对于一个给定的连通图科普存在一条恰好包含所有线段并且没有重复的路径，这条路径就是「一笔画」。 寻找连通图这条路径的过程就是「一笔画」的游戏过程，如下： 游戏的实现「一笔画」的实现不复杂，笔者把实现过程分成两步： 底图绘制 交互绘制 「底图绘制」把连通图以「点线」的形式显示在画布上，是游戏最容易实现的部分；「交互绘制」是用户绘制解题路径的过程，这个过程会主要是处理点与点动态成线的逻辑。 底图绘制「一笔画」是多关卡的游戏模式，笔者决定把关卡（连通图）的定制以一个配置接口的形式对外暴露。对外暴露关卡接口需要有一套描述连通图形状的规范，而在笔者面前有两个选项： 点记法 线记法 举个连通图 —— 五角星为例来说一下这两个选项。 点记法如下：123456789101112131415levels: [ // 当前关卡 &#123; name: \"五角星\", coords: [ &#123;x: Ax, y: Ay&#125;, &#123;x: Bx, y: By&#125;, &#123;x: Cx, y: Cy&#125;, &#123;x: Dx, y: Dy&#125;, &#123;x: Ex, y: Ey&#125;, &#123;x: Ax, y: Ay&#125; ] &#125; ...] 线记法如下：12345678910111213levels: [ // 当前关卡 &#123; name: \"五角星\", lines: [ &#123;x1: Ax, y1: Ay, x2: Bx, y2: By&#125;, &#123;x1: Bx, y1: By, x2: Cx, y2: Cy&#125;, &#123;x1: Cx, y1: Cy, x2: Dx, y2: Dy&#125;, &#123;x1: Dx, y1: Dy, x2: Ex, y2: Ey&#125;, &#123;x1: Ex, y1: Ey, x2: Ax, y2: Ay&#125; ] &#125;] 「点记法」记录关卡通关的一个答案，即端点要按一定的顺序存放到数组 coords中，它是有序性的记录。「线记法」通过两点描述连通图的线段，它是无序的记录。「点记法」最大的优势是表现更简洁，但它必须记录一个通关答案，笔者只是关卡的搬运工不是关卡创造者，所以笔者最终选择了「线记法」。：） 交互绘制在画布上绘制路径，从视觉上说是「选择或连接连通图端点」的过程，这个过程需要解决2个问题： 手指下是否有端点 选中点到待选中点之间能否成线 收集连通图端点的坐标，再监听手指滑过的坐标可以知道「手指下是否有点」。以下伪代码是收集端点坐标： 12345678// 端点坐标信息let coords = [];lines.forEach((&#123;x1, y1, x2, y2&#125;) =&gt; &#123; // (x1, y1) 在 coords 数组不存在 if(!isExist(x1, y1)) coords.push([x1, y1]); // (x2, y2) 在 coords 数组不存在 if(!isExist(x2, y2)) coords.push([x2, y2]);&#125;); 以下伪代码是监听手指滑动：1234567891011121314easel.addEventListener(\"touchmove\", e =&gt; &#123; let x0 = e.targetTouches[0].pageX, y0 = e.targetTouches[0].pageY; // 端点半径 ------ 取连通图端点半径的2倍，提升移动端体验 let r = radius * 2; for(let [x, y] of coords)&#123; if(Math.sqrt(Math.pow(x - x0, 2) + Math.pow(y - y0), 2) &lt;= r)&#123; // 手指下有端点，判断能否连线 if(canConnect(x, y)) &#123; // todo &#125; break; &#125; &#125;&#125;) 在未绘制任何线段或端点之前，手指滑过的任意端点都会被视作「一笔画」的起始点；在绘制了线段（或有选中点）后，手指滑过的端点能否与选中点串连成线段需要依据现有条件进行判断。 上图，点A与点B可连接成线段，而点A与点C不能连接。笔者把「可以与指定端点连接成线段的端点称作有效连接点」。连通图端点的有效连接点从连通图的线段中提取：1234567891011121314coords.forEach(coord =&gt; &#123; // 有效连接点（坐标）挂载在端点坐标下 coord.validCoords = []; lines.forEach((&#123;x1, y1, x2, y2&#125;) =&gt; &#123; // 坐标是当前线段的起点 if(coord.x === x1 &amp;&amp; coord.y === y1) &#123; coord.validCoords.push([x2, y2]); &#125; // 坐标是当前线段的终点 else if(coord.x === x2 &amp;&amp; coord.y === y2) &#123; coord.validCoords.push([x1, y1]); &#125; &#125;)&#125;) But…有效连接点只能判断两个点是否为底图的线段，这只是一个静态的参考，在实际的「交互绘制」中，会遇到以下情况： 如上图，AB已串连成线段，当前选中点B的有效连接点是 A 与 C。AB 已经连接成线，如果 BA 也串连成线段，那么线段就重复了，所以此时 BA 不能成线，只有 AC 才能成线。 对选中点而言，它的有效连接点有两种： 与选中点「成线的有效连接点」 与选中点「未成线的有效连接点」 其中「未成线的有效连接点」才能参与「交互绘制」，并且它是动态的。 回头本节内容开头提的两个问题「手指下是否有端点」 与 「选中点到待选中点之间能否成线」，其实可合并为一个问题：手指下是否存在「未成线的有效连接点」。只须把监听手指滑动遍历的数组由连通图所有的端点坐标 coords 替换为当前选中点的「未成线的有效连接点」即可。 至此「一笔画」的主要功能已经实现。可以抢先体验一下： https://leeenx.github.io/OneStroke/src/onestroke.html 自动识图笔者在录入关卡配置时，发现一个7条边以上的连通图很容易录错或录重线段。笔者在思考能否开发一个自动识别图形的插件，毕竟「一笔画」的图形是有规则的几何图形。 上面的关卡「底图」，一眼就可以识出三个颜色： 白底 端点颜色 线段颜色 并且这三种颜色在「底图」的面积大小顺序是：白底 &gt; 线段颜色 &gt; 端点颜色。底图的「采集色值表算法」很简单，如下伪代码： 12345678910let imageData = ctx.getImageData();let data = imageData.data;// 色值表let clrs = new Map();for(let i = 0, len = data.length; i &lt; len; i += 4) &#123; let [r, g, b, a] = [data[i], data[i + 1], data[i + 2], data[i + 3]]; let key = `rgba($&#123;r&#125;, $&#123;g&#125;, $&#123;b&#125;, $&#123;a&#125;)`; let value = clrs.get(key) || &#123;r, g, b, a, count: 0&#125;; clrs.has(key) ? ++value.count : clrs.set(rgba, &#123;r, g, b, a, count&#125;);&#125; 对于连通图来说，只要把端点识别出来，连通图的轮廓也就出来了。 端点识别理论上，通过采集的「色值表」可以直接把端点的坐标识别出来。笔者设计的「端点识别算法」分以下2步： 按像素扫描底图直到遇到「端点颜色」的像素，进入第二步 从底图上清除端点并记录它的坐标，返回继续第一步 伪代码如下：12345678910for(let i = 0, len = data.length; i &lt; len; i += 4) &#123; let [r, g, b, a] = [data[i], data[i + 1], data[i + 2], data[i + 3]]; // 当前像素颜色属于端点 if(isBelongVertex(r, g, b, a)) &#123; // 在 data 中清空端点 vertex = clearVertex(i); // 记录端点信息 vertexes.push(vertext); &#125;&#125; But… 上面的算法只能跑无损图。笔者在使用了一张手机截屏做测试的时候发现，收集到的「色值表」长度为 5000+ ！这直接导致端点和线段的色值无法直接获得。 经过分析，可以发现「色值表」里绝大多数色值都是相近的，也就是在原来的「采集色值表算法」的基础上添加一个近似颜色过滤即可以找出端点和线段的主色。伪代码实现如下： 123456789let lineColor = vertexColor = &#123;count: 0&#125;;for(let clr of clrs) &#123; // 与底色相近，跳过 if(isBelongBackground(clr)) continue; // 线段是数量第二多的颜色，端点是第三多的颜色 if(clr.count &gt; lineColor.count) &#123; [vertexColor, lineColor] = [lineColor, clr] &#125;&#125; 取到端点的主色后，再跑一次「端点识别算法」后居识别出 203 个端点！这是为什么呢？ 上图是放大5倍后的底图局部，蓝色端点的周围和内部充斥着大量噪点（杂色块）。事实上在「端点识别」过程中，由于噪点的存在，把原本的端点被分解成十几个或数十个小端点了，以下是跑过「端点识别算法」后的底图： 通过上图，可以直观地得出一个结论：识别出来的小端点只在目标（大）端点上集中分布，并且大端点范围内的小端点叠加交错。 如果把叠加交错的小端点归并成一个大端点，那么这个大端点将十分接近目标端点。小端点的归并伪代码如下： 1234567891011121314for(let i = 0, len = vertexes.length; i &lt; len - 1; ++i) &#123; let vertexA = vertexes[i]; if(vertextA === undefined) continue; // 注意这里 j = 0 而不是 j = i +1 for(let j = 0; j &lt; len; ++j) &#123; let vertexB = vertexes[j]; if(vertextB === undefined) continue; // 点A与点B有叠加，点B合并到点A并删除点B if(isCross(vertexA, vertexB)) &#123; vertexA = merge(vertexA, vertexB); delete vertexA; &#125; &#125;&#125; 加了小端点归并算法后，「端点识别」的准确度就上去了。经笔者本地测试已经可以 100% 识别有损的连通图了。 线段识别笔者分两个步骤完成「线段识别」： 给定的两个端点连接成线，并采集连线上N个「样本点」； 遍历样本点像素，如果像素色值不等于线段色值则表示这两个端点之间不存在线段 如何采集「样式点」是个问题，太密集会影响性能；太疏松精准度不能保证。 在笔者面前有两个选择：N 是常量；N 是变量。假设 N === 5。局部提取「样式点」如下： 上图，会识别出三条线段：AB, BC 和 AC。而事实上，AC不能成线，它只是因为 AB 和 BC 视觉上共一线的结果。当然把 N 值向上提高可以解决这个问题，不过 N 作为常量的话，这个常量的取量需要靠经验来判断，果然放弃。 为了避免 AB 与 BC 同处一直线时 AC 被识别成线段，其实很简单 —— 两个「样本点」的间隔小于或等于端点直径。假设 N = S / (2 * R)，S 表示两点的距离，R 表示端点半径。局部提取「样式点」如下： 如上图，成功地绕过了 AC。「线段识别算法」的伪代码实现如下：123456789101112131415for(let i = 0, len = vertexes.length; i &lt; len - 1; ++i) &#123; let &#123;x: x1, y: y1&#125; = vertexes[i]; for(let j = i + 1; j &lt; len; ++j) &#123; let &#123;x: x2, y: y2&#125; = vertexes[j]; let S = Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2)); let N = S / (R * 2); let stepX = (x1 - x2) / N, stepY = (y1 - y2) / n; while(--N) &#123; // 样本点不是线段色 if(!isBelongLine(x1 + N * stepX, y1 + N * stepY)) break; &#125; // 样本点都合格 ---- 表示两点成线，保存 if(0 === N) lines.push(&#123;x1, y1, x2, y2&#125;) &#125;&#125; 性能优化由于「自动识图」需要对图像的的像素点进行扫描，那么性能确实是个需要关注的问题。笔者设计的「自动识图算法」，在识别图像的过程中需要对图像的像素做两次扫描：「采集色值表」 与 「采集端点」。在扫描次数上其实很难降低了，但是对于一张 750 * 1334 的底图来说，「自动识图算法」需要遍历两次长度为 750 * 1334 * 4 = 4,002,000 的数组，压力还是会有的。笔者是从压缩被扫描数组的尺寸来提升性能的。 被扫描数组的尺寸怎么压缩？笔者直接通过缩小画布的尺寸来达到缩小被扫描数组尺寸的。伪代码如下： 12345// 要压缩的倍数let resolution = 4;let [width, height] = [img.width / resolution &gt;&gt; 0, img.height / resolution &gt;&gt; 0];ctx.drawImage(img, 0, 0, width, height);let imageData = ctx.getImageData(), data = imageData; 把源图片缩小4倍后，得到的图片像素数组只有原来的 4^2 = 16倍。这在性能上是很大的提升。 使用「自动识图」的建议尽管笔者在本地测试的时候可以把所有的「底图」识别出来，但是并不能保证其它开发者上传的图片能否被很好的识别出来。笔者建议，可以把「自动识图」做为一个单独的工具使用。 笔者写了一个「自动识图」的单独工具页面：https://leeenx.github.io/OneStroke/src/plugin.html可以在这个页面生成对应的关卡配置。 结语下面是本文介绍的「一笔画」的线上 DEMO 的二维码： 游戏的源码托管在：https://github.com/leeenx/OneStroke其中游戏实现的主体代码在：https://github.com/leeenx/OneStroke/blob/master/src/script/onestroke.es6自动识图的代码在：https://github.com/leeenx/OneStroke/blob/master/src/script/oneStrokePlugin.es6 感谢耐心阅读完本文章的读者。本文仅代表笔者的个人观点，如有不妥之处请不吝赐教。 如果对「H5游戏开发」感兴趣，欢迎关注我们的专栏。 .post-content sup a { vertical-align: unset; }","pubDate":"Thu, 02 Nov 2017 11:30:37 GMT","guid":"https://aotu.io/notes/2017/11/02/onestroke/","category":"H5游戏开发"},{"title":"H5游戏开发：横屏适配","link":"https://aotu.io/notes/2017/10/18/landscape_mode_in_html5_game/","description":"对于移动端的轻量级 HTML5 互动小游戏（简称为 H5 轻互动)，如果从屏幕呈现模式来划分的话，可以归类为：竖屏式和横屏式。 HTML5互动小游戏案例截图 平常我们做过的需求里，主要是以竖屏式为主，而横屏式较少。对于竖屏式场景来说，大家的经验会比较丰富，因此，此次主要式探讨下横屏式场景下的一些需要注意的点，特别是怎样去做横屏适配。 对于 H5 轻互动游戏来说，要实现横屏的话，主要是解决两点：1.无论用户手持方向如何，都需要保证屏幕横向显示。2.由于屏幕分辨率的多样化，因此就算是横屏下也是需要进行横屏适配，保证画面在所有分辨率下都能够合理适配。 下面，我们针对这两点分别阐述如何解决。 强制横屏显示页面内容显示方向可分为竖排方向和横排方向，如下图所示。 页面内容显示方式：竖向排版和横向排版 对于竖屏式 H5 轻互动来说，页面会被期望保持竖排方向显示。而如果页面出现横排方向显示的情况，开发者往往会选择利用提示蒙层来进行友好提示，让用户自主保持竖屏体验，如下图所示。 提示蒙层提醒用户保持竖屏体验 同样地，在横屏式 H5 轻互动游戏中可以采取相同的措施进行简单处理，在页面内容按竖排方向显示时，开发者进行对用户提示其保持横屏体验。 但是，这对用户体验并不友好，因为这对于那些习惯于打开锁定为竖排方向功能（如下图所示）的 iOS 平台用户，或者是关闭屏幕旋转功能（如下图所示）的 Android 平台用户来说，他们需要多一个处理步骤——先关闭竖排方向锁定或是开启屏幕旋转，然后再横向手持设备。 竖排方向锁定功能（iOS）与屏幕旋转（Android）功能 因此，更好的做法是强制横屏显示，对屏幕 resize 事件进行监听，当判断为竖屏时将整个根容器进行逆时针 CSS3 旋转 90 度即可，代码如下所示。 1234567891011121314151617181920212223242526// 利用 CSS3 旋转 对根容器逆时针旋转 90 度var detectOrient = function() &#123; var width = document.documentElement.clientWidth, height = document.documentElement.clientHeight, $wrapper = document.getElementById(\"J_wrapper\"), style = \"\"; if( width &gt;= height )&#123; // 横屏 style += \"width:\" + width + \"px;\"; // 注意旋转后的宽高切换 style += \"height:\" + height + \"px;\"; style += \"-webkit-transform: rotate(0); transform: rotate(0);\"; style += \"-webkit-transform-origin: 0 0;\"; style += \"transform-origin: 0 0;\"; &#125; else&#123; // 竖屏 style += \"width:\" + height + \"px;\"; style += \"height:\" + width + \"px;\"; style += \"-webkit-transform: rotate(90deg); transform: rotate(90deg);\"; // 注意旋转中点的处理 style += \"-webkit-transform-origin: \" + width / 2 + \"px \" + width / 2 + \"px;\"; style += \"transform-origin: \" + width / 2 + \"px \" + width / 2 + \"px;\"; &#125; $wrapper.style.cssText = style;&#125;window.onresize = detectOrient;detectOrient(); 但是！这里有坑：如果你是采用 CreateJS 框架进行开发，那么就不能通过 CSS3 途径对包含 Canvas 的根容器进行旋转处理，因为旋转后会导致 Canvas 内的舞台元素的事件响应位置错乱。解决办法是，换成利用 CreateJS 框架内的 Stage 的 rotation 属性对整个舞台旋转处理，代码如下： 12345678910if(self.isPortrait) &#123; // 竖屏 // 舞台旋转 self.stage.x = self.canvasHeight; // 注意：x偏移相当于旋转中点处理，更简单 self.stage.rotation = 90; // more...&#125;else &#123; // 横屏 self.stage.x = 0; self.stage.rotation = 0; // more...&#125; 横屏适配处理面对移动端多分辨率繁复冗杂的情况，我们对于一般情况下（也就是常见的竖屏式）页面适配处理可以说是烂熟于心，但是切换到横屏式场景下，同样的页面适配方法可以直接应用吗？会不会有什么问题呢？ 下面笔者分别从 DOM 和 Canvas 两方面去着手阐述如何做横屏适配处理。 解决 DOM 的横屏适配问题在移动端，常见的移动端适配方案是 REM 方案，而为了减少 JS 与 CSS 的耦合，笔者团队开发页面时采用的是 VW + REM 方案。（想要了解该方案的同学可详细阅读《利用视口单位实现适配布局》）。 因为页面适配的场景往往是竖屏式的，因此 VW + REM 方案表现得十分完美。但是遇上横屏式，它的缺点就暴露了出来。 现行的 vw 单位适配方案带来的问题 如上图所示，由于响应断点的限制最大宽度处理，会导致页面两侧留白，当然这可以通过去掉最大宽度限制来解决。而真正的缺点在于，由于 vw 单位的特性，适配换算大小是根据屏幕宽度而言的，因此屏幕宽度越大导致容器、文字会越大，还可能导致 DOM 元素超出屏幕外，且文字过大并不是我们所想要的用户体验。 那么，换成 px 单位的固定布局如何？ 但 px 单位的固定布局只适合于部分场景，对于需要内容全屏覆盖的场景（如下图所示），就可能存在这样的不理想的用户体验：绝对定位的元素之间空隙过大，导致布局不美观，又或者空隙过小，导致元素叠放被遮挡。 px单位固定布局适配方案带来的问题 我们了解到，vw 单位的特点是适配换算大小时是根据屏幕宽度而定的，那么在强制横屏显示时，我们就可以同理转换为屏幕高度来而定，也就是 vw 单位替换成 vh 单位。 这样进一步改良之后就会得到满意的适配效果，如下图所示。 更好的适配解决方案—— vw、vh 单位搭配 具体实现可参考如下 SCSS 代码：123456789101112$vw_base: 375;$vw_fontsize: 20;html &#123; font-size: 20px; //不支持vw单位时，回退到px单位 font-size: ($vw_fontsize / $vw_base) * 100vw;&#125;@media screen and (orientation: landscape) &#123; html &#123; font-size: 20px; font-size: ($vw_fontsize / $vw_base) * 100vh; &#125;&#125; 解决 Canvas 的横屏适配问题解决 Canvas 的横屏适配问题，目前在实际应用中有两种主流的方案： 通过做两套Canvas的方案。 采用缩放的手段进行适配的方案。 两套 Canvas 的方案的做法是，页面包含两个 Canvas 分别用于横竖屏时的相应显示，但是它们的数据是打通的。但是，该方案难免会有局限性，比较适合游戏逻辑数据处理简单、且舞台元素少且居中的场景； 而缩放适配方案做法是，采用的最为常见的缩放手段——利用 CSS3 Transform 的 scale 属性，达到“一种设计尺寸适配多种分辨率屏幕”的目的。 采用了不同适配方案的案例 在市面上的一些成熟的主流 HTML5 游戏引擎，例如 Cocos2D、Laya、Egret 等等，它们本身就集成了横屏适配的方案。如果你有去了解过，可以发现它们普遍都是采用缩放的理念进行适配。 但是，对于我们常用的 CreateJS、PixiJS 框架来说，它们并没有配套的现成的横屏适配解决方案可以被采用的，尤其是我们如果采用原生 Javascript 去开发一个横屏游戏的时候。 因此，下面我们来研究下如何解决 Canvas 横屏适配问题。 注意：下面文中示例代码都是在 CreateJS 框架的基础上进行编写的。 选用合适的缩放模式横屏适配的核心是缩放，通过 scale 属性等手法将Canvas缩放至适合屏幕窗口大小。类似于 background-size 属性的表现，缩放适配也可以有很多种模式，或有裁剪或无裁剪，或根据长边缩放或根据短边缩放等等。根据一些常见的实际应用场景，有比较常用的五种缩放模式：Contain、Cover、Fill、Fixed-Width、Fixed-Height。根据游戏的不同的实际场景需求，我们可以选其中一种缩放模式进行适配。 下面，我们逐一解释以上五种缩放模式的定义、实现与其适用的场景。 a. Contain模式 Canvas可以类比为一张图，而图片的适配，我们可以联想到经常用以适配背景图片的属性 background-size ，其属性值包括 contain、cover。 借助 contain 的概念，我们把缩放的其中一种模式称为 Contain 模式。因为在这种模式下，舞台内容（gameArea）会保持宽高比进行缩放适配浏览器可视窗口（window），缩放至其能显示完整的舞台内容。 根据下图推导，我们可以得出在这种缩放模式下的缩放比例（scaleRadio），为浏览器可视窗口与游戏内容的宽度比或高度比之间较小者。 Contain 模式下的缩放比例推导图 根据推导结论，简单代码实现如下： 1234567// Contain模式核心原理函数CONTAIN: function()&#123; var self = this; self.radioX = self.radioY = Math.min((self.winWidth / self.designWidth) , (self.winHeight / self.designHeight)); self.canvasWidth = self.designWidth; self.canvasHeight = self.designHeight;&#125; 可以看出，在 Contain 模式下，如果舞台内容宽高比与浏览器可视窗口的宽高比不相等时，舞台内容并没有填满整个浏览器可视窗口，此时就会出现上下或左右两侧会存在留空部分。 对于这种 Contain 模式，会比较适合舞台背景为纯色或者是渐变类型的H5轻互动，舞台内容与窗口的紧邻处得以自然过渡衔接，不会突兀。 b. Cover模式 同样地，借助 cover 的概念把其中一种模式称为 Cover 模式。在这种模式下，舞台内容（gameArea）会保持宽高比进行缩放适配浏览器可视窗口（window），缩放至舞台内容填满窗口。 根据下图推导，我们可以得出在这种缩放模式下的缩放比例（scaleRadio），为浏览器可视窗口与游戏内容的宽度比或高度比之间较大者。 Cover 模式下的缩放比例推导图 根据推导结论，简单代码实现如下：1234567// Cover模式核心原理函数COVER: function()&#123; var self = this; self.radioX = self.radioY = Math.max((self.winWidth / self.designWidth) , (self.winHeight / self.designHeight)); self.canvasWidth = self.designWidth; self.canvasHeight = self.designHeight;&#125; 在 Cover 模式下，如果舞台内容宽高比与浏览器可视窗口的宽高比不相等时，由于舞台内容需要填满整个浏览器可视窗口，此时就会出现上下或者左右两侧被裁剪的情况。 那么，如果能保证游戏场景内的重点显示内容全部显示，被裁剪内容无关紧要时，那么这种 H5 轻互动类型就可以考虑采用 Cover 模式。 怎么做到保证想要重点显示的内容可以不被裁剪呢？这时要谈到一个“安全区域”的概念，指的是绝对不会被裁剪的内容区域，它应该是由最小的屏幕可视窗口（目前应该是 iPhone 4 ）与最大的屏幕可视窗口（目前应该是 iPhone 7 Plus）叠加后得出的重叠区域，如下图所示。 “安全区域”即为红色虚线框内部分 开发者应该在设计阶段与设计师、产品等相关人员进行沟通，告知其不想被裁剪的内容都应该在“安全区域”进行设计布局。 c. Fill模式 Fill 模式，可以类比为 backgrouns-size: 100% 100% 的表现，在这种模式下，不会保持宽高比，舞台内容（gameArea）的宽高分别按照舞台内容与浏览器可视窗口（window）的宽度比与高度比进行缩放，缩放至舞台内容拉伸铺满窗口。 根据下图推导，我们可以得出在这种缩放模式下的缩放比例（scaleRadio），为对于游戏内容的宽应用其与可视窗口的宽度比，而游戏内容的高应用其与可视窗口的高度比。 Fill 模式下的缩放比例推导图 根据推导结论，简单代码实现如下：12345678// Fill模式核心原理函数FILL: function()&#123; var self = this; self.radioX = (self.winWidth / self.stageWidth); self.radioY = (self.winHeight / self.stageHeight); self.canvasWidth = self.designWidth; self.canvasHeight = self.designHeight;&#125; 这种模式下既不会留空，也不会被裁剪，但是在舞台内容宽高比与浏览器可视窗口的宽高比不相等时，显示的内容会有一定程度的拉伸形变。 这种暴力的处理方式虽然免去了留空和裁剪的烦恼，但是会存在拉伸形变，这就得看是否能够被接受了。 d. Fixed-Width模式 区别于图像，Canvas 是可以进行动态绘制大小的。所以，我们可以考虑根据屏幕窗口大小变化来动态绘制 Canvas。从保持舞台横向内容不变的角度考虑，我们提出这样的模式：舞台内容（gameArea）等比进行缩放至与浏览器可视窗口的一致的宽度大小，而舞台的高度（Canvas高度）进行重新绘制其高度为浏览器可视窗口的高度，称之为 Fixed-Width 模式。 根据下图推导，我们可以得出在这种缩放模式下的缩放比例（scaleRadio），为浏览器可视窗口与游戏内容的宽度比。 Fixed-Width 模式下的缩放比例推导图 根据推导结论，简单代码实现如下：1234567// Fixed-Width模式核心原理函数FIXED_WIDTH: function()&#123; var self = this; self.radioX = self.radioY = self.winWidth / self.designWidth; self.canvasWidth = self.designWidth; self.canvasHeight = self.winHeight / self.radioY;&#125; 在 Fixed-Width 模式下，无论在什么分辨率下，舞台横向内容保持不变，而纵向高度则会动态裁补，这就会比较适用于那些场戏场景可以纵向拓展的 H5 轻互动类型。 e. Fixed-Height模式 说完 Fixed-Width 模式，换个角度考虑便得出 Fixed-Height 模式，舞台内容（gameArea）等比进行缩放至与浏览器可视窗口的一致的高度大小，而舞台的宽度（Canvas宽度）进行重新绘制其宽度为浏览器可视窗口的宽度。 根据下图推导，我们可以得出在这种缩放模式下的缩放比例（scaleRadio），为浏览器可视窗口与游戏内容的高度比。 Fixed-Height 模式下的缩放比例推导图 根据推导结论，简单代码实现如下：1234567// Fixed-Height模式核心原理函数FIXED_HEIGHT: function()&#123; var self = this; self.radioX = self.radioY= self.winHeight / self.designHeight; self.canvasWidth = self.winWidth / self.radioX; self.canvasHeight = self.designHeight;&#125; 与 Fixed-Width 模式相反，Fixed-Height 模式下，舞台纵向内容保持不变，而横向宽度则会动态裁补。对于这种模式的应用场景应该会比较广泛，譬如常见的跑酷游戏类型H5轻互动。 加入重定位和重绘制策略综合以上五种缩放模式，我们可以看到对于 Cover、Fixed-Width、Fixed-Height 模式而言，有存在被裁剪的可能性。特别是 Fixed-Height 模式，对于横屏游戏来说这是比较常用的模式，但是在屏幕较小的时候难免会被裁剪，而且我们是不希望贴边元素被裁剪掉的，譬如位于右上角的音乐图标。而对于 Fixed-Width、Fixed—Height 模式，它们还存在舞台区域需要补充绘制的情况，因此对某些舞台元素来说需要重新设定其渲染大小。 所以，除了基本的缩放适配模式实现之外，为了解决贴边元素不被裁剪以及对一些舞台元素重绘制的需求，我们还需要加入两个策略：重定位和重绘制。 a. 重定位 贴边元素重定位策略的实现原理很简单，对需要重新定位的元素对象额外设置 top、left、right、bottom 的自定义属性（当然你可以命名为其他属性名），这样我们就可以在适配的时候根据这些自定义属性以及实际显示的 Canvas 大小进行重新计算位置。 为了保证性能，下面是策略里需要注意的地方： 在舞台里，并不是所有游戏元素都是需要被重定位的，因此我们只需要创建一个数组记录需要被重定位的元素。 适当控制重定位次数，我们不需要在每一帧 tick 绘制的时候都进行重定位，只需要在 Canvas 大小改变的时候进行处理。 以下是重定位策略相关的代码：123456789101112131415161718192021222324252627282930// halfCutHeight、halfCutWidth是根据适配后的实际Canvas大小计算出来的相对距离_setSize: function()&#123; // ... if(self.isPortrait) &#123; // ... self.halfCutWidth = (self.canvasWidth * self.radioY - this.winWidth ) / 2 / self.radioY; self.halfCutHeight = (self.canvasHeight * self.radioX - this.winHeight) / 2 / self.radioX; &#125;else &#123; // ... self.halfCutWidth = (self.canvasWidth * self.radioX - this.winWidth ) / 2 / self.radioX; self.halfCutHeight = (self.canvasHeight * self.radioY - this.winHeight) / 2 / self.radioY; &#125; // ...&#125;,// 贴边元素重定位核心处理函数_adjustPosition: function(item)&#123; var self = this; item &amp;&amp; self.adjustPositionArr.push(item); self.adjustPositionArr.map(function(item, index, arr)&#123; (typeof item.top == \"number\") &amp;&amp; (item.y = item.top + self.halfCutHeight &gt;= 0 ? self.halfCutHeight : 0); (typeof item.left == \"number\") &amp;&amp; (item.x = item.left + self.halfCutWidth &gt;= 0 ? self.halfCutWidth : 0); (typeof item.bottom == \"number\") &amp;&amp; (item.y = self.canvasHeight - item.getBounds().height - item.bottom + self.halfCutHeight &gt;= 0 ? self.halfCutHeight : 0); (typeof item.right == \"number\") &amp;&amp; (item.x = self.canvasWidth - item.getBounds().width - item.right - self.halfCutWidth); &#125;);&#125;,// 暴露方法：提供给开发者记录需要重定位的贴边元素adjustPosition: function(item)&#123; var self = this; self._adjustPosition(item);&#125; b. 重绘制 对于一些以舞台区域（gameArea）作为其大小设置的参考标准的元素，在适配时遇到需要补全绘制区域时，舞台区域大小发生变化，相应地，该元素就需要进行重新绘制，这就是重绘制策略的存在意义。 同样地，为了保证性能，重绘制策略也是同样需要保证： 创建对应的数组记录全显图形对象。 不在每一帧 tick 时进行重绘制，只在适配的时候重绘制。 以下是重绘制策略的相关代码：12345678910111213// 全显图形重绘制核心处理函数_adjustFullSize: function(item)&#123; var self = this; item &amp;&amp; self.adjustFullSizeArr.push(item); self.adjustFullSizeArr.map(function(item, index, arr)&#123; item.drawRect(0, 0, self.canvasWidth, self.canvasHeight); &#125;);&#125;,// 暴露方法：提供给开发者记录需要重绘制的全显图形adjustPosition: function(item)&#123; var self = this; self._adjustPosition(item);&#125; 至此，Canvas 横屏适配问题才得以完全解决。 这部分内容篇幅较长，笔者简单总结下，一个简单的解决 Canvas 横屏适配问题的方案至少需要包括两点实现： 选用合适的缩放模式。方案内置五种缩放模式，在实际应用中根据场景不同而采用不同的缩放进行适配。 加入重定位和重绘制策略。为了保证贴边元素不被裁剪以及舞台元素动态渲染大小以适应舞台区域的动态变化。 最终的整体效果可前往体验地址进行体验，体验时可点击文本元素进行切换模式。另外，整体的实现方案是基于 CreateJS 框架进行实现的，文中的实现方案的代码会托管笔者github上。 后话本文主要的核心在于探讨横屏游戏中的处理点与解决方案，因此如果实现代码方面有任何错漏之处，请大胆地提出纠正吧！又或者读者们有更好的见解之处，也欢迎留言分享噢。 如果对「H5游戏开发」感兴趣，欢迎关注我们的专栏。 参考资料《如何打造一个高效适配的H5》《Cocos2d-JS的屏幕适配方案》《Cocos2d-JS 多分辨率适配方案》《Cocos2d-JS 对齐策略》《Laya引擎－自动横屏适配》《Phaser－scaleManager对象》《How to create mobile games for different screen sizes and resolutions》《Egret－屏幕适配策略》","pubDate":"Wed, 18 Oct 2017 01:10:00 GMT","guid":"https://aotu.io/notes/2017/10/18/landscape_mode_in_html5_game/","category":"H5游戏开发"},{"title":"js创建一条通用链表","link":"https://aotu.io/notes/2017/10/13/make-a-chain-class/","description":"什么是「链表科普」？ 链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。 什么是「顺序存储结构科普」？ 在计算机中用一组地址连续的存储单元依次存储线性表的各个数据元素,称作线性表的顺序存储结构。 多数高级语言的「数组」使用「顺序存储结构」，不过早期的 javascript 引擎用了「链式存储结构」。Chrome 的 V8 的数组使用了「顺序存储结构」与「链式存储结构」混合模式；大多数情况下，V8 下的数组是「顺序存储结构」，所以我们就假装 V8 的数组使用的是「顺序存储结构」吧！（-_-! 心虚） javascript 开发需要「链表」吗？自问自答大多数情况下 javascript 开发关心的是「数据的逻辑结构」而非「数据的存储结构」，似乎「链表」跟 javascript 开发没什么关系。But…「链表」在一些情况下能有效提升代码的性能，特别是在H5游戏的过程中。 假设有一个业务需要高频率地向一张「线性表科普」插入或删除节点。通常笔者会用数组表示「线性表」，因为 javascript 的数组有一系列成熟好用的 APIs （如：unshift / push / shift / pop / splice 等）可以完成插入与删除节点的操作。但是数组（顺序存储结构）的 unshift &amp; shift &amp; splice 的算法时间复杂度是 O(n) ，这情况可能「链表」是更好的选择。 图解链表先看一下最简单的单向链表： 往链表里插入一个节点： 剔除链表里的节点： 往链表里插入一条链表： 剪除链表的一段切片： 通过上面的图示，可以很清晰地了解到单链表的优势：插入节点或链表片段的算法时间复杂度为O(2)；删除节点或链表片段的算法时间复杂度为O(1) 实现双向链表「单向链表」效率虽然高，不过局限性比较大。所以笔者想实现的是「双向链表」。双向链表插入节点或链表的算法时间复杂度为 O(4)，删除节点或链表片段的算法时间复杂度为O(2)。双向链表的结构如下： 节点指针 ——「前驱」与「后继」 链表指针 —— 「头指针」、「尾指针」和「游标指针」 用一个匿名对象作为链表上的节点，如下伪代码：1234567function generateNode(data) &#123; return &#123; data: data, // 数据域 next: null, // 前驱指针 prev: null // 后继指针 &#125; &#125; 声明变量 HEAD, TAIL, POINTER &amp; length 分别指代「头指针」，「尾指针」，「游标指针」和 「链表长度」，那么构建一个双向链表如下伪代码： 1234567891011121314151617181920let HEAD, TAIL, POINTER, length = 0; // 创建一条长度为5的双向链表[0, 1, 2, 3, 4].forEach((data, index, arr) =&gt; &#123; let node = generateNode(data); // 第一个节点 if(index === 0) &#123; HEAD = node; &#125; else &#123; // 指定前驱后继指针 [node.prev, POINTER.next] = [POINTER, node]; // 最后一个节点 index === arr.length - 1 &amp;&amp; (TAIL = node) &#125; // 指向当前节点 POINTER = node; ++length; &#125;); // 游标指针回退到头部POINTER = HEAD; 链表结构本身是个很简单的结构，20行左右代码可以完成双向链表数据结构的构建。 定制 APIs上一节虽然实现了「双向链表」的数据结构，但链表还处在很原始的状态，操作起来比较麻烦，为了方便操作链表得为链表量身定做一套 APIs。数组有一系列成熟且好用的 APIs，笔者想借鉴数组的 APIs 为链表定制以下的 APIs: Name Detail Name Detail Name Detail Name Detail shift 参见数组 unshift 参见数组 pop 参见数组 push 参见数组 slice 参见数组 splice 参见数组 concat 参见数组 reverse 参见数组 sort 参见数组 indexOf 参见数组 length[属性] 参见数组 - - at 指针定位 prev 指针前移 next 指针后退 curr 当前指针 first 头节点 last 尾节点 remove 删除节点 clone 克隆链表 insertAfter 插入节点 insertBefore 插入节点 insertChainAfter 插入链表 insertChainBefore 插入链表 HEAD[属性] 头指针 TAIL[属性] 尾指针 setHead 重置头指针 setTail 重置尾指针 POINTER[属性] 游标指针（当前位置） setPointer 设置当前指针 - - - - 上表与数组同名的 APIs，表示用法与功能与数组一样。 为了突显「链表性」笔者添加了四个 insert*。insert* 的作用是向主链表指定位置插入节点或链表。APIs 不小心被笔者写多了，这里就不展开介绍它们的实现过程了。有兴趣的同学可以移步：https://github.com/leeenx/es6-utils/blob/master/modules/Chain_v2.js 循环链表笔者以往都是用数组来模拟循环链表，如下：12345678910Array.prototype.next = function() &#123; var cur = this[0]; this.push(this.shift()); return cur;&#125;var arr = [1, 2, 3, 4, 5]; var count = 0; while(count++&lt;20) &#123; console.log(arr.next());&#125; 有了 Chain 类后，可以直接这样写： 123456let circle = new Chain([1, 2, 3, 4, 5]); // 链表头咬尾circle.TAIL.next = circle.HEAD; for(let i = 0; i &lt; 20; ++i) &#123; console.log(chain.next()); &#125; 结语近期有些同学在问笔者，使用 Chain 类真的可以提升性能吗？这个需要分情况，如果是比较长的「线性表」做高频的「删除」或「插入」操作，自然是使用 Chain 有算法上的优势。但是，对于短的「线性表」来说，使用数组更快一些，因为 V8 的数组性能相当高，笔者认为小于 200 的「线性表」都可以直接使用数组。 本文实现的 Chain 类托管在：https://github.com/leeenx/es6-utils/blob/master/modules/Chain_v2.js 感谢耐心阅读完本文章的读者。本文仅代表笔者的个人观点，如有不妥之处请不吝赐教。 .post-content sup a { vertical-align: unset; }","pubDate":"Fri, 13 Oct 2017 14:30:48 GMT","guid":"https://aotu.io/notes/2017/10/13/make-a-chain-class/","category":"Web开发"},{"title":"wxapp-market 小程序营销组件","link":"https://aotu.io/notes/2017/09/28/wxapp-market/","description":"介绍wxapp-market 是凹凸实验室推出的一款基于微信小程序的营销组件，用于快速开发营销玩法类小程序项目页面，包含大转盘、刮刮乐、老虎机、水果机、九宫格翻纸牌、摇一摇、手势解锁等多种营销组件。 项目地址：https://github.com/o2team/wxapp-market 特性 基于小程序 WXML 提供模板（template）模块化开发 简单好用、易扩展 支持多种营销玩法 预览可通过微信web开发者工具，进行预览体验 快速上手拉取仓库1git clone git@github.com:o2team/wxapp-market.git 查看组件文件 大转盘 (Big wheel) : /components/wheel/ 刮刮乐 (Scratch tickets) : /components/scratch/ 老虎机 (Slot machine) : /components/slotMachine/ 水果机 (Fruit machine) : /components/fruitMachine/ 九宫格翻纸牌 (Grid card) : /components/card/ 摇一摇 (Shake) : /components/shake/ 手势解锁 (Gesture lock) : /components/lock/ 引入组件引入对应所需组件，实例组件对象、配置参数即可。如大转盘组件： WXSS中引用样式：@import &quot;../../components/wheel/wheel.wxss&quot; WXML中引用结构：&lt;import src=&quot;../../components/wheel/wheel.wxml&quot;/&gt; JS中引用：import Wheel from &quot;../../components/wheel/wheel.js&quot; 12345678910new Wheel(this,&#123; areaNumber: 8, //抽奖间隔 speed: 16, //转动速度 awardNumer: 2, //中奖区域从1开始 mode: 1, //1是指针旋转，2为转盘旋转 callback: (idx, award) =&gt; &#123; //结束回调 &#125;&#125;) 更多使用说明，请阅读文档 wxapp-market 结语wxapp-market 是希望帮助开发者能够更快、更低门槛地开发出含营销功能的微信小程序，同时希望与众多开发者一起打造维护好用、易扩展的小程序营销组件库。 欢迎各位端友使用 wxapp-market，如果你在使用过程中遇到问题，或者有好的建议，欢迎给我们提 Issue 或者 Pull Request。","pubDate":"Thu, 28 Sep 2017 12:03:25 GMT","guid":"https://aotu.io/notes/2017/09/28/wxapp-market/","category":"Web开发"},{"title":"实现 setTimeout & setInterval 暂停的方案","link":"https://aotu.io/notes/2017/09/25/manage-setTimeout-an-setInterval/","description":"在管理 setTimeout &amp; setInterval 这两个 APIs 时，笔者通常会在顶级（全局）作用域创建一个叫 timer 的对象，在它下面有两个数组成员 —— {sto, siv}，用它们来分别存储需要管理的 setTimeoutID / setIntervalID。如下： 1234var timer = &#123; sto: [], siv: []&#125;; 在使用 setTimeout / setInterval 的时候，这样调用：12345678// 标记 setTimeoutIDtimer.sto.push( setTimeout(function() &#123;console.log(\"3s\")&#125;, 3000); ); // 标记 setIntervalIDtimer.siv.push( setInterval(function() &#123;console.log(\"1s\")&#125;, 1000)); 在页面需要 clearTimeout \\ clearInterval 的时候，这样调用： 1234// 批量清除 setTimeouttimer.sto.forEach(function(sto) &#123;clearTimeout(sto)&#125;); // 批量清除 setIntervaltimer.siv.forEach(function(siv) &#123;clearInterval(siv)&#125;); 暂停 &amp; 恢复近段时间，笔者发现很多业务都需要「暂停」和「恢复」setTimeout &amp; setInterval 的功能，而仅靠原生的四个 APIs（setTimeout / setIntervale / clearTimeout / clearInterval）是不够用的。于是，笔者对 timer 进行了扩展，使它具备了「暂停」和「恢复」的功能，如下： 1234// 暂停所有的 setTimeout &amp; setIntervaltimer.pause(); // 恢复所有的 setTimeout &amp; setIntervaltimer.resume(); 扩展后的 timer对象下面挂载6个基础的 APIs。 setTimeout setInterval clearTimeout clearInterval pause resume 使用 timer.set* &amp; timer.clear* 来代替原生的 set* &amp; clear*。笔者把扩展后的 timer 托管在 GitHub 仓库上，有兴趣的同学可以移步：https://github.com/leeenx/timer CreateJS 的启发在使用 CreateJS 开发一些项目的过程中，笔者发现通过设置 createjs.Ticker.paused = true / false，可以暂停/恢复 createjs.Tween 上的动画。于是笔者借用 createjs.Tween 模拟了 setTimeout &amp; setInterval 的功能，如下：12345678// setTimeoutcreatejs.setTimeout = function(fn, delay) &#123; createjs.Tween.get().wait(delay).call(fn);&#125;//setIntervalcreatejs.setInterval = function(fn, delay) &#123; createjs.Tween.get().wait(delay).call(fn).loop = 1; &#125; 具体的代码笔者托管在：createjs.timer。其实就是在 createjs 对象下挂载四个 APIs: setTimeout setInterval clearTimeout clearInterval 使用方法与原生的 setTimeout &amp; setInterval 一样，如下：12let siv = createjs.setInterval(() =&gt; console.log(\"1s\"), 1000);createjs.setTimeout(() =&gt; createjs.clearInterval(siv), 5000); 时间轴驱动的 timercreatejs.timer 在 CreateJS 项目的开发给笔者带来了极大的便利，但是它必须依赖 createjs.Tween 模块。于是笔者就在思考能否创建一个跟第三方框架无关并且又可以在第三方框架上使用的 timer。 createjs.Ticker.paused 为什么能暂停 createjs.Tween 上的动画的？createjs.Tween 中每一个动画都有一条自己的时间轴，这条时间轴是通过 createjs.Ticker 来驱动的；当 createjs.Ticker 被暂停后，createjs.Tween 中的每个动画的时间轴也会失去动力而暂停下来。 createjs.Ticker 的作用是提供一个刷新 canvas 画面帧频，通常是使用 requestAnimationFrame or setInterval 来实现的。如果 timer 内部存在一条时间轴，这条时间轴由第三方驱动，那么 timer 就可以与第三方框架状态同步了。 笔者是这样设计 timer 的结构： queue —— 存放 setTimeout or setInterval 的队列； updateQueue —— 驱动 queue 的内部 API； update —— 外部接口，用于对接第三方 Ticker。 实现的伪代码如下： 123456789101112131415161718192021222324/* @queue 成员的结构如下： &#123; fn: fn, // 回调函数 type: \"timeout or interval\", // 类型 elapsed: 0, // 时间轴进度 delay: delay // 目标时长 &#125;*/let queue = new Map(); function updateQueue(delta) &#123; queue.forEach((item, id) =&gt; &#123; item.elapsed += delta; if(item.elapsed &gt;= item.delay) &#123; item.fn(); // 从 queue 中删除 setTimeout 成员，interval 成员继续循环 item.type === \"timeout\" ? delete(id) : (item.elapsed = 0); &#125; &#125;); &#125;// 对外接口this.update = function(delta) &#123; updateQueue(delta); &#125; timer 的具体实现可以参考：https://github.com/leeenx/es6-utils#timer timer 与 CreateJS 一起使用：123456// es6 代码import timer from './modules/timer'; // 统一 tickercreatejs.Ticker.addEventListener(\"tick\", function(e) &#123; e.paused || timer.update(e.delta); &#125;); timer 与 PIXI 一起使用：123456// es6 代码import timer from './modules/timer'; // 统一 tickerapp.ticker.add(\"tick\", function() &#123; timer.update(app.ticker.elapsedMS); &#125;); 附上 PIXI 的线上 DEMO，二维码如下： 总结感谢阅读完本文章的读者。本文仅代表个人观点，希望能帮助到有相关问题的朋友，如果本文有不妥之处请不吝赐教。","pubDate":"Mon, 25 Sep 2017 08:04:51 GMT","guid":"https://aotu.io/notes/2017/09/25/manage-setTimeout-an-setInterval/","category":"Web开发"},{"title":"H5游戏开发：贪吃蛇","link":"https://aotu.io/notes/2017/09/25/h5game-snake/","description":"贪吃蛇的经典玩法有两种： 积分闯关 一吃到底 第一种是笔者小时候在掌上游戏机最先体验到的（不小心暴露了年龄），具体玩法是蛇吃完一定数量的食物后就通关，通关后速度会加快；第二种是诺基亚在1997年在其自家手机上安装的游戏，它的玩法是吃到没食物为止。笔者要实现的就是第二种玩法。 MVC设计模式基于贪吃蛇的经典，笔者在实现它时也使用一种经典的设计模型：MVC（即：Model - View - Control）。游戏的各种状态与数据结构由 Model 来管理；View 用于显示 Model 的变化；用户与游戏的交互由 Control 完成（Control 提供各种游戏API接口）。 Model 是游戏的核心也是本文的主要内容；View 会涉及到部分性能问题；Control 负责业务逻辑。 这样设计的好处是： Model完全独立，View 是 Model 的状态机，Model 与 View 都由 Control 来驱动。 Model看一张贪吃蛇的经典图片。 贪吃蛇有四个关键的参与对象： 蛇（snake） 食物（food） 墙（bounds） 舞台（zone） 舞台是一个 m * n 的矩阵（二维数组），矩阵的索引边界是舞台的墙，矩阵上的成员用于标记食物和蛇的位置。 空舞台如下：123456789101112[ [0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0],] 食物（F）和蛇（S）出现在舞台上：123456789101112[ [0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0], [0,0,F,0,0,0,0,0,0,0], [0,0,0,S,S,S,S,0,0,0], [0,0,0,0,0,0,S,0,0,0], [0,0,0,0,S,S,S,0,0,0], [0,0,0,0,S,0,0,0,0,0], [0,0,0,0,S,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0],] 由于操作二维数组不如一维数组方便，所以笔者使用的是一维数组， 如下：123456789101112[ 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,F,0,0,0,0,0,0,0, 0,0,0,S,S,S,S,0,0,0, 0,0,0,0,0,0,S,0,0,0, 0,0,0,0,S,S,S,0,0,0, 0,0,0,0,S,0,0,0,0,0, 0,0,0,0,S,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,] 舞台矩阵上蛇与食物只是舞台对二者的映射，它们彼此都有独立的数据结构： 蛇是一串坐标索引链表； 食物是一个指向舞台坐标的索引值。 蛇的活动蛇的活动有三种，如下： 移动（move） 吃食（eat） 碰撞（collision） 移动蛇在移动时，内部发生了什么变化？ 蛇链表在一次移动过程中做了两件事：向表头插入一个新节点，同时剔除表尾一个旧节点。用一个数组来代表蛇链表，那么蛇的移动就是以下的伪代码：123function move(next) &#123; snake.pop() &amp; snake.unshift(next);&#125; 数组作为蛇链表合适吗？这是笔者最开始思考的问题，毕竟数组的 unshift &amp; pop 可以无缝表示蛇的移动。不过，方便不代表性能好，unshift 向数组插入元素的时间复杂度是 O(n)， pop 剔除数组尾元素的时间复杂度是 O(1)。 蛇的移动是一个高频率的动作，如果一次动作的算法复杂度为 O(n) 并且蛇的长度比较大，那么游戏的性能会有问题。笔者想实现的贪吃蛇理论上讲是一条长蛇，所以笔者在本文章的回复是 —— 数组不适合作为蛇链表。 蛇链表必须是真正的链表结构。链表删除或插入一个节点的时间复杂度为O(1)，用链表作为蛇链表的数据结构能提高游戏的性能。javascript 没有现成的链表结构，笔者写了一个叫 Chain 的链表类，Chain 提供了 unshfit &amp; pop。以下伪代码是创建一条蛇链表： 1let snake = new Chain(); 由于篇幅问题这里就不介绍 Chain 是如何实现的，有兴趣的同学可以移步到: https://github.com/leeenx/es6-utils#chain 吃食 &amp; 碰撞「吃食」与「碰撞」区别在于吃食撞上了「食物」，碰撞撞上了「墙」。笔者认为「吃食」与「碰撞」属于蛇一次「移动」的三个可能结果的两个分支。蛇移动的三个可能结果是：「前进」、「吃食」和「碰撞」。 回头看一下蛇移动的伪代码：123function move(next) &#123; snake.pop() &amp; snake.unshift(next);&#125; 代码中的 next 表示蛇头即将进入的格子的索引值，只有当这个格子是0时蛇才能「前进」，当这个格子是 S 表示「碰撞」自己，当这个格子是 F表示吃食。 好像少了撞墙？笔者在设计过程中，并没有把墙设计在舞台的矩阵中，而是通过索引出界的方式来表示撞墙。简单地说就是 next === -1 时表示出界和撞墙。 以下伪代码表示蛇的整上活动过程：123456789101112// B 表示撞墙let cell = -1 === next ? B : zone[next];switch(cell) &#123; // 吃食 case F: eat(); break; // 撞到自己 case S: collision(S); break; // 撞墙 case B: collision(B): break; // 前进 default: move;&#125; 随机投食随机投食是指随机挑选舞台的一个索引值用于映射食物的位置。这似乎很简单，可以直接这样写：12// 伪代码food = Math.random(zone.length) &gt;&gt; 0; 如果考虑到投食的前提 —— 不与蛇身重叠，你会发现上面的随机代码并不能保证投食位置不与蛇身重叠。由于这个算法的安全性带有赌博性质，且把它称作「赌博算法」。为了保证投食的安全性，笔者把算法扩展了一下：1234567// 伪代码function feed() &#123; let index = Math.random(zone.length) &gt;&gt; 0; // 当前位置是否被占用 return zone[index] === S ? feed() : index;&#125;food = feed(); 上面的代码虽然在理论上可以保证投食的绝对安全，不过笔者把这个算法称作「不要命的赌徒算法」，因为上面的算法有致命的BUG —— 超长递归 or 死循环。 为了解决上面的致命问题，笔者设计了下面的算法来做随机投食：1234567891011121314151617181920// 伪代码function feed() &#123; // 未被占用的空格数 let len = zone.length - snake.length; // 无法投食 if(len === 0) return ; // zone的索引 let index = 0, // 空格计数器 count = 0, // 第 rnd 个空格子是最终要投食的位置 rnd = Math.random() * count &gt;&gt; 0 + 1; // 累计空格数 while(count !== rnd) &#123; // 当前格子为空，count总数增一 zone[index++] === 0 &amp;&amp; ++count; &#125; return index - 1;&#125;food = feed(); 这个算法的平均复杂度为 O(n/2)。由于投食是一个低频操作，所以 O(n/2)的复杂度并不会带来任何性能问题。不过，笔者觉得这个算法的复杂度还是有点高了。回头看一下最开始的「赌博算法」，虽然「赌博算法」很不靠谱，但是它有一个优势 —— 时间复杂度为 O(1)。 「赌博算法」的靠谱概率 = (zone.length - snake.length) / zone.length。snake.length 是一个动态值，它的变化范围是：0 ~ zone.length。推导出「赌博算法」的平均靠谱概率是： 「赌博算法」平均靠谱概率 = 50% 看来「赌博算法」还是可以利用一下的。于是笔者重新设计了一个算法：12345678910// 伪代码function bet() &#123; let rnd = Math.random() * zone.length &gt;&gt; 0; return zone[rnd] === 0 ? rnd : -1;&#125;function feed() &#123; ...&#125;food = bet();if(food === -1) food = feed(); 新算法的平均复杂度可以有效地降低到 O(n/4)，人生有时候需要点运气 : )。 View在 View 可以根据喜好选择一款游戏渲染引擎，笔者在 View 层选择了 PIXI 作为游戏游戏渲染引擎。 View 的任务主要有两个： 绘制游戏的界面； 渲染 Model 里的各种数据结构 也就是说 View 是使用渲染引擎还原设计稿的过程。本文的目的是介绍「贪吃蛇」的实现思路，如何使用一个渲染引擎不是本文讨论的范畴，笔者想介绍的是：「如何提高渲染的效率」。 在 View 中显示 Model 的蛇可以简单地如以下伪代码：12345678910// 清空 View 上的蛇view.snake.clean();model.snake.forEach( (node) =&gt; &#123; // 创建 View 上的蛇节点 let viewNode = createViewNode(node); // 并合一条新蛇 view.snake.push(viewNode); &#125;); 上面代码的时间复杂度是 O(n)。上面介绍过蛇的移动是一个高频的活动，我们要尽量避免高频率地运行 O(n) 的代码。来分析蛇的三种活动：「移动」，「吃食」，「碰撞」。首先，Model 发生了「碰撞」，View 应该是直接暂停渲染 Model 里的状态，游戏处在死亡状态，接下来的事由 Control 处理。Model 中的蛇（链表）在一次「移动」过程中做了两件事：向表头插入一个新节点，同时剔除表尾一个旧节点；蛇（链表）在一次「吃食」过程中只做一件事：向表头插入一个新节点。 如果在 View 中对 Model 的蛇链表做差异化检查，View 只增量更新差异部分的话，算法的时间复杂度即可降低至 O(1) ~ O(2) 。以下是优化后的伪代码： 12345678910111213141516171819202122232425let snakeA = model.snake, snakeB = view.snake;// 增量更新尾部while(snakeB.length &lt;= snakeA.length) &#123; headA = snakeA.next(); // 头节点匹配 if(headA.data === headB.data) break; // 不匹配 else &#123; // 向snakeB插入头节点 if(snakeA.HEAD === headA.index) &#123; snakeB.unshift(headA.data); &#125; // 向snakeB插入第二个节点 else snakeB.insertAfter(0, headA.data); &#125;&#125;// 增量更新头部let tailA = snakeA.last(), tailB;while(snakeB.length !== 0) &#123; tailB = snakeB.last(); // 尾节点匹配 if(tailA.data === tailB.data) break; // 不匹配 else snakeB.pop();&#125; ControlControl 主要做 3 件事： 游戏与用户的互动 驱动 Model 同步 View 与 Model 「游戏与用户的互动」是指向外提供游戏过程需要使用到的 APIs 与 各类事件。笔者规划的 APIs 如下： name type deltail init method 初始化游戏 start method 开始游戏 restart method 重新开始游戏 pause method 暂停 resume method 恢复 turn method 控制蛇的转向。如：turn(“left”) destroy method 销毁游戏 speed property 蛇的移动速度 事件如下： name detail countdown 倒时计 eat 吃到食物 before-eat 吃到食物前触发 gameover 游戏结束 事件统一挂载在游戏实例下的 event 对象下。1snake.event.on(\"countdown\", (time) =&gt; console.log(\"剩余时间：\", time)); 「驱动 Model 」只做一件事 —— 将 Model 的蛇的方向更新为用户指定的方向。「同步 View 与 Model 」也比较简单，检查 Model 是否有更新，如果有更新通知 View 更新游戏界面。 结语下面是本文介绍的贪吃蛇的线上 DEMO 的二维码： 游戏的源码托管在：https://github.com/leeenx/snake 感谢耐心阅读完本文章的读者。本文仅代表笔者的个人观点，如有不妥之处请不吝赐教。 如果对「H5游戏开发」感兴趣，欢迎关注我们的专栏。","pubDate":"Mon, 25 Sep 2017 02:19:06 GMT","guid":"https://aotu.io/notes/2017/09/25/h5game-snake/","category":"H5游戏开发"},{"title":"whistle 使用实践","link":"https://aotu.io/notes/2017/08/29/an-introduction-to-whistle/","description":"whistle 是一款用 Node 实现的跨平台的 Web 调试代理工具，支持查看修改 http(s)、Websocket 连接的请求和响应内容。简而言之就是 Node 版的 Fiddler、Charles，不过这个工具能远比后两者更加适合 Web 开发者、使用更简单、功能也更加实用，而笔者使用了 1 个月后发现完全可以代替 Fiddler、Charles。 安装&amp;运行whistle 运行时会监听一个端口，把 Chrome（或其他程序）转发到该端口的数据处理后再返回，而在 Chrome 里则通过一个代理层把请求转发到相应端口。 Chrome 插件：whistle for Chrome Node 端的 CI 工具 12345# 安装sudo npm i -g whistle# 运行w2 start 详见：安装方法 最后，打开 http://local.whistlejs.com/#network 即可进入控制台界面 常用功能一览 绑定host 12# 说明：相当于浏览器层的host文件，如果找不到再去查找本机的host文件192.168.0.1 mydomain.com 替换请求 12# 说明：请求百度的时候会返回京东的页面内容https://m.baidu.com https://wq.jd.com/ 修改返回码 12# 说明：使 http 返回 404https://m.baidu.com statusCode://404 往 html 插入脚本 123# 说明：会在网页最后以 script 标签的形式插入，花括号的值是内置编辑器保存的文件，在主菜单 “Value” 下可找到https://wq.jd.com js://&#123;test.js&#125;https://wq.jd.com js:///Users/myname/test/test.js 往 html 插入样式 12# 说明：在网页里以 style 标签的形式插入https://wq.jd.com css://&#123;test.css&#125; 文本类请求 append 内容、替换返回内容 1234# 说明：会把内容 append 到请求后面http://mydomain.com/style.css resAppend://&#123;myAppend.css&#125;# 说明：完全替换请求内容http://mydomain.com/style.css resBody://&#123;myResBody.css&#125; weinre 调试页面 12# 说明：为 https://wq.jd.com 页面快速添加一个 weinre 调试脚本，点击 http://local.whistlejs.com/weinre/client/#debug_mypage 或界面主菜单 “Weinre” 可打开 inspect 界面调试该页面https://wq.jd.com weinre://debug_mypage 更多的使用方法可以参考 whistle 协议列表 小结从上面可以看出 whistle 的大致工作流程： 配置需要修改的 url 地址 编写\u001c URI 协议，如 statusCode:// 编写协议对应的参数，如 statusCode://404 可以看出 whistle 的操作都是通过文本配置去实现，比较符合程序员的思维。 whistle 可操作的资源的 request 、respond 的 header、 body， 其中 header 里面的 query 、ua 、 cookie、status Code 等数据对前端来说非常熟悉， 也都有相应的协议去操作这些数据。 另外， whistle 很多操作协议都是针对前端开发友好的，比如 html、 js 、css 等类型的请求的修改协议对于前端程序猿来说都非常亲切。 使用建议1. 代替本地的 host 文件由于 whistle 兼容操作系统的 host 语法格式，所以在浏览器层面的 host 配置可轻松代替本地的 host 文件。这样做的主要好处是无缓存，切换时生效更快。 有一个技巧就是在 “Rules” 界面下，可配多套 host 配置，比如 dev、gamma 等满足开发需求。 2. 多终端代理 手机的 wifi 设置里，打开代理，连接本机 ip 和 8899 端口即可查看手机的网页请求 电脑其余程序的代理设置，也可通过本机 ip 和 8899 端口的形式使用 whistle 查看请求，比如微信 web 开发者工具\u001c 注意以上操作均需要在同一个局域网内 3. 转换 http 协议转发协议+域名转发，轻松本地模拟 https ，访问线上的 https 域名实际上指向的是本地的 http 调试地址。1https://wq.jd.com http://localhost:9000 注意，涉及到 https 的请求都需要您的电脑和手机等都安装 whistle 提供的证书，详情可看文档。 4. mock 数据whistle 提供了一个强大的 mock 数据的插件，强大之处是可以结合 js 语句 + mock 语法去生成数据。举一个简单的例子说明用法： 先安装插件：1npm i -g whistle.vase 在 “Plugins” 菜单打开 vase 的界面，新建一个名字为 “mock_json_demo” 的配置，并选择模板为 mock 。输入如下内容：1234567&#123; \"list|5\": [&#123; \"name\": \"@string\", \"avatar\": \"http://lorempixel.com/100/100/\", \"id|+1\": 10000 &#125;]&#125; 不熟悉 mock 语法的朋友可以到这里了解一下 在 “Rules” 下配置一条 vase 的规则：1http://mock.local/data.json vase://mock_json_demo 打开测试地址 http://mock.local/data.json ，即可看到模拟的数据。 有读者可能会问，如果想更自由度更高一点，用 js 去生成数据是否可行？ 当然可行，vase 提供了一种 “script” 模板可实现这种需求，里面可以写一些简单的 javascript API，还提供了 req（request）等内置数据对象，可以获取如请求的 headers、method、body、query、url 等数据。 既然这些数据都有了，是不是可以搞事情了？我有一个大胆的想法，请看下面的例子： 在 vase 界面新建一个名为 “json_engine_script” 数据模板，并选择 “script” 模板引擎。12345678910111213var json = merge(&#123; page: req.query.pi, // 取url查询参数的分页字段，加到要返回的数据里，达到模拟分页数据的效果 total: 60&#125;, render('mock_json_demo', null, 'mock')); // render 可以渲染上文提到名为“mock_json_demo”的数据模板，返回一个jsonif (req.query.callback) &#123; // 如果查询参数带了callback，则返回jsonp out(header('content-type', 'application/javascript; charset=utf8')); var json_text = join([req.query.callback+'(', json, ')']); // join是内置方法，可合并一组数据 out(json_text); // 向body输出数据&#125; else &#123; // 没有callback则返回json out(header('content-type', 'application/json; charset=utf8')); out(json);&#125; 在 “Rules” 输入以下配置：123http://mock.local/data.json vase://json_engine_script# 注释掉上一条配置# http://mock.local/data.json vase://mock_json_demo 打开 http://mock.local/data.json?callback=cb&amp;pi=1 ，可尝试改变、删除 callback、pi 参数，会发现返回的数据会随之改变。 至此就完成了一个简单的、有一定扩展性的 restful 数据接口模拟。 5. mock &amp; more在现有的开发工作流里，在需求开发完毕进入测试后，相信有不少团队都是需要测试人员单独模拟数据去测试页面功能。所以在开发阶段的 mock 数据、whistle rules 是不是可以直接共享给测试去使用了呢？因为纯文本配置的数据共享起来毕竟比较方便。 如果项目迭代比较快，觉得共享多份 mock 配置数据不方便，是否可以单独搞个 mock server（市面上已有类似服务比如 easy mock，我们团队也有一个好用的文档管理 &amp; mock server），whistle 只进行请求转发，而开发与测试人员只需要共享 whistle rules 即可？ 结语总体来说 whistle 的玩法还是蛮多的，入门也比较简单，不过也是依然缺少一些功能，比如调试 websocket\u001c、图片 等的能力，也缺少一些账户系统 &amp; 共享配置的能力，希望作者以后能够考虑完善一下这些功能吧，使这个工具更加好玩。 参考资料：whistle 文档 https://avwo.github.io/whistle/ vase 文档 https://github.com/whistle-plugins/whistle.vase mock 文档 https://github.com/nuysoft/Mock/wiki","pubDate":"Tue, 29 Aug 2017 04:00:00 GMT","guid":"https://aotu.io/notes/2017/08/29/an-introduction-to-whistle/","category":"Web开发"},{"title":"Three.js 现学现卖","link":"https://aotu.io/notes/2017/08/28/getting-started-with-threejs/","description":"引言 三维计算机图形和二维计算机图形的不同之处在于计算机存储了几何数据的三维表示，其用于计算和绘制最终的二维图像。——《3D computer graphics》 随着 WebGL 标准的快速推进，越来越多团队尝试在浏览器上推出可交互的 3D 作品。相较于二维场景，它更能为用户带来真实和沉浸的体验。 然而 OpenGL 和 WebGL（基于 OpenGL ES） 都比较复杂，Three.js 则更适合初学者。本文将分享一些 Three.js 的基础知识，希望能让你能有所收获。 当然，分享的知识点也不会面面俱到，想更深入的学习，还得靠大家多看多实践。另外，为了控制篇幅，本文更倾向于通过案例中的代码和注释进行阐述一些细节。 若想系统学习，笔者认为看书是一个不错的选择： Three.js开发指南（原书第2版） 购买链接&gt;&gt; 尽管由于 Three.js 的不断迭代，书本上的某些 API 已改变（或弃用），甚至难免还有一些错误，但这些并不影响整体的阅读。 Canvas 2D如引言中说道，3D 图像在计算机中最终以 2D 图像呈现。因此，渲染模式只是作为一个载体。下面我们用 JavaScript（无依赖） 在 Canvas 2D 渲染一个在正视图/透视图中的立方体。 正视图中的立方体： See the Pen 3D Orthographic View by SitePoint (@SitePoint) on CodePen. 透视图中的立方体： See the Pen 3D Perspective View by SitePoint (@SitePoint) on CodePen. 若要将三维图形渲染在二维屏幕上，需要将三维坐标以某种方式转为二维坐标。但对于更复杂的场景，大量坐标的转换和阴影等耗性能操作无疑需要 Web 提供更高效的渲染模式。 另外，想了解上述两个案例的实现原理，可查看译文：《用 JavaScript 构建一个3D引擎》。 WebGLWebGL（Web Graphics Library）在 GPU 中运行。因此需要使用能够在 GPU 上运行的代码。这样的代码需要提供成对的方法（其中一个叫顶点着色器， 另一个叫片段着色器），并且使用一种类 C/C++ 的强类型语言 GLSL（OpenGL Shading Language)。 每一对方法组合起来称为一个 program（着色程序）。 顶点着色器的作用是计算顶点的位置。根据计算出的一系列顶点位置，WebGL 可以对点、线和三角形在内的一些图元进行光栅化处理。当对这些图元进行光栅化处理时需要使用片段着色器方法。片段着色器的作用是计算出当前绘制图元中每个像素的颜色值。 用 WebGL 绘制一个三角形： See the Pen WebGL - Fundamentals by Jc (@JChehe) on CodePen. 查看上述案例的代码实现后，我们发现绘制一个看似简单的三角形其实并不简单，它需要我们学习更多额外的知识。 因此，对于刚入门的开发者来说，直接使用 WebGL 来绘制并拼装出几何体是不现实的。但我们可以在了解 WebGL 的基础知识后，再通过 Three.js 这类封装后的库来现实我们的需求。 Three.js打开 Three.js 官方文档 并阅览左侧的目录，发现该文档对初学者并不友好。但相对于其他资料，它提供了最新的 API 说明，尽管有些描述并不详细（甚至需要在懂 WebGL 等其他知识的前提下，才能了解某个术语的意思）。下面提供两个 Three.js 的相关图片资料，希望它们能让你对 Three.js 有个整体的认识： Three.js 文档结构：图片来自&gt;&gt; Three.js 核心对象结构和基本的渲染流程：图片来自&gt;&gt; Three.js 的基本要素我们先通过一个简单但完整的案例来了解 Three.js 的基本使用：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 引入 Three.js 库&lt;script src=\"https://unpkg.com/three\"&gt;&lt;/script&gt;function init () &#123; // 获取浏览器窗口的宽高，后续会用 var width = window.innerWidth var height = window.innerHeight // 创建一个场景 var scene = new THREE.Scene() // 创建一个具有透视效果的摄像机 var camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 800) // 设置摄像机位置，并将其朝向场景中心 camera.position.x = 10 camera.position.y = 10 camera.position.z = 30 camera.lookAt(scene.position) // 创建一个 WebGL 渲染器，Three.js 还提供 &lt;canvas&gt;, &lt;svg&gt;, CSS3D 渲染器。 var renderer = new THREE.WebGLRenderer() // 设置渲染器的清除颜色（即背景色）和尺寸。 // 若想用 body 作为背景，则可以不设置 clearColor，然后在创建渲染器时设置 alpha: true，即 new THREE.WebGLRenderer(&#123; alpha: true &#125;) renderer.setClearColor(0xffffff) renderer.setSize(width, height) // 创建一个长宽高均为 4 个单位长度的立方体（几何体） var cubeGeometry = new THREE.BoxGeometry(4, 4, 4) // 创建材质（该材质不受光源影响） var cubeMaterial = new THREE.MeshBasicMaterial(&#123; color: 0xff0000 &#125;) // 创建一个立方体网格（mesh）：将材质包裹在几何体上 var cube = new THREE.Mesh(cubeGeometry, cubeMaterial) // 设置网格的位置 cube.position.x = 0 cube.position.y = -2 cube.position.z = 0 // 将立方体网格加入到场景中 scene.add(cube) // 将渲染器的输出（此处是 canvas 元素）插入到 body 中 document.body.appendChild(renderer.domElement) // 渲染，即摄像机拍下此刻的场景 renderer.render(scene, camera)&#125;init() 在线案例： See the Pen threejs-blog-01-hello-world by Jc (@JChehe) on CodePen. 看完上述案例代码后，你可能会产生以下几个疑问： Three.js 的单位是什么？ 坐标系的位置和指向是？ 具有透视效果的摄像机的参数含义是？ Mesh 的作用是？ 下面我们逐一回答： 1. Three.js 的单位是什么？ 答：Three.js 基于 OpenGL，那我们从 OpenGL 文档看到这么一句话： “The preceding paragraph mentions inches and millimeters - do these really have anything to do with OpenGL? The answer is, in a word, no. The projection and other transformations are inherently unitless. If you want to think of the near and far clipping planes as located at 1.0 and 20.0 meters, inches, kilometers, or leagues, it’s up to you. The only rule is that you have to use a consistent unit of measurement. Then the resulting image is drawn to scale.” ——《OpenGL Programming Guide》中文：前面段落提及的英寸和毫米真的和 OpenGL 有关系吗？没有。投影和其它变换在本质上都是无单位的。如果你想把近距离和远距离的裁剪平面分别放置在 1.0 和 20.0 米/英寸/千米/里格，这取决于你。这里唯一的要求是你必须使用统一的测量单位，然后按比例绘制最终图像。 2. 坐标系的位置和指向是？ 答：Three.js 的坐标系是遵循右手坐标系，如下图： 右手坐标系 坐标系的原点在画布中心（canvas.width / 2, canvas.height / 2）。我们可以通过 Three.js 提供的 THREE.AxisHelper() 辅助方法将坐标系可视化。 RGB颜色分别代表 XYZ 轴： See the Pen threejs-blog-02-axis by Jc (@JChehe) on CodePen. 另外，补充一点：对于旋转 cube.rotation 正值是逆时针旋转，负值是顺时针旋转。 3. 具有透视效果的摄像机的参数含义是？答： THREE.PerspectiveCamera(fov, aspect, near, far) 具有 4 个参数，具体解释如下： 参数 描述 fov fov 表示视场，即摄像机能看到的视野。比如，人类有接近 180 度的视场，而有些鸟类有接近 360 度的视场。但是由于计算机不能完全显示我们能够所看到的景象，所以一般会选择一块较小的区域。对于游戏而言，视场大小通常为 60 ~ 90 度。推荐默认值为：50 aspect 指定渲染结果的横向尺寸和纵向尺寸的比值。在我们的示例中，由于使用窗口作为输出界面，所有使用的是窗口的长宽比。推荐默认值：window.innerWidth / window.innerHeight near 指定从距离摄像机多近的距离开始渲染。推荐默认值：0.1 far 指定摄像机从它所处的位置开始能看到多远。若过小，那么场景中的远处不会被渲染；若过大，可能会影响性能。推荐默认值：1000 透视摄像机的参数图示 摄像机的 fov 属性指定了横向视场。基于 aspect 属性，纵向视场也就相应确定了。而近面和远面则指定了可视化区域的前后边界，即两者之间的元素才可能被渲染。 Three.js 还提供了其他 3 种摄像机：CubeCamera、OrthographicCamera、StereoCamera。 其中 OrthographicCamera 是正交投影摄像机，他不具有透视效果，即物体的大小不受远近距离的影响。 切换正交投影摄像机和透视摄像机： See the Pen switchCamera by Jc (@JChehe) on CodePen. 4. Mesh 的作用是？ 答：Mesh 好比一个包装工，它将『可视化的材质』粘合在一个『数学世界里的几何体』上，形成一个『可添加到场景的对象』。当然，创建的材质和几何体可以多次使用（若需要）。而且，包装工不止一种，还有 Points（点集）、Line（线/虚线） 等。 同一个几何体的多种表现形式： See the Pen multi-appearance by Jc (@JChehe) on CodePen. Three.js 提供的几何体从 Three.js 文档目录的 Geometries 可看到，Three.js 已为我们提供了很多现成的几何体，但如果对几何知识不常接触，可能就很难从它的英文名字联想到其实际的形状。下面我们将它们一次性罗列出来： Three.js 提供的 18 个几何体： See the Pen all-the-geometry by Jc (@JChehe) on CodePen. 目前 Three.js 一共提供了 22 个 Geometry，除了 EdgesGeometry、ExtrudeGeometry、TextGeometry、WireframeGeometry，上面涵盖 18 个，它们分别是底层的 planeGeometry 和以下 17 种（顺序与上述案例一一对应，下同）： BoxGeometry（长方体） CircleGeometry（圆形） ConeGeometry（圆锥体） CylinderGeometry（圆柱体） DodecahedronGeometry（十二面体） IcosahedronGeometry（二十面体） LatheGeometry（让任意曲线绕 y 轴旋转生成一个形状，如花瓶） OctahedronGeometry（八面体） ParametricGeometry（根据参数生成形状） PolyhedronGeometry（多面体） RingGeometry（环形） ShapeGeometry（二维形状） SphereGeometry（球体） TetrahedronGeometry（四面体） TorusGeometry（圆环体） TorusKnotGeometry（换面纽结体） TubeGeometry（管道） \\ \\ \\ 剩余的 TextGeometry、EdgesGeometry、WireframeGeometry、ExtrudeGeometry 我们单独拿出来解释： See the Pen the-remaining-geomtry by Jc (@JChehe) on CodePen. / TextGeometry / EdgesGeometry WireframeGeometry ExtrudeGeometry 如案例所示，EdgesGeometry 和 WireframeGeometry 更多地可能作为辅助功能去查看几何体的边和线框（三角形图元）。 ExtrudeGeometry 则是按照指定参数将一个二维图形沿 z 轴拉伸出一个三维图形。 TextGeometry 则需要从外部加载特定格式的字体文件（可在 typeface.js 网站上进行转换）进行渲染，其内部依然使用 ExtrudeGeometry 对字体进行拉伸，从而形成三维字体。另外，该类字体的本质是一系列类似 SVG 的指令。所以，字体越简单（如直线越多），就越容易被正确渲染。 以上就是目前 Three.js 提供的几何体，当然，这些几何体的形状也不仅于此，通过改变参数即能生成更多种类的形状，如 THREE.CircleGeometry 可生成扇形。 另外，通过 console.log 查看任意一个 geometry 对象可发现，在 Three.js 中的几何体基本上是三维空间中的点集（即顶点）和这些顶点连接起来的面组成的。以立方体为例（widthSegments、heightSegments、depthSegments 均为 1 时）： 一个立方体有 8 个顶点，每个顶点通过 x、y 和 z 坐标来定义。 一个立方体有 6 个面，而每个面都包含两个由 3 个顶点组成的三角形。 对于 Three.js 提供的几何体，我们不需要自己定义这些几何体的顶点和面，只需提供 API 指定的参数即可（如长方体的长宽高）。当然，你仍然可以通过定义顶点和面来创建自定义的几何体。如： 123456789101112131415161718192021222324252627282930var vertices = [ new THREE.Vector3(1, 3, 1), new THREE.Vector3(1, 3, -1), new THREE.Vector3(1, -1, 1), new THREE.Vector3(1, -1, -1), new THREE.Vector3(-1, 3, -1), new THREE.Vector3(-1, 3, 1), new THREE.Vector3(-1, -1, -1), new THREE.Vector3(-1, -1, 1)]var faces = [ new THREE.Face3(0, 2, 1), new THREE.Face3(2, 3, 1), new THREE.Face3(4, 6, 5), new THREE.Face3(6, 7, 5), new THREE.Face3(4, 5, 1), new THREE.Face3(5, 0, 1), new THREE.Face3(7, 6, 2), new THREE.Face3(6, 3, 2), new THREE.Face3(5, 7, 0), new THREE.Face3(7, 2, 0), new THREE.Face3(1, 3, 4), new THREE.Face3(3, 6, 4)]var geometry = new THREE.Geometry()geometry.vertices = verticesgeometry.faces = facesgeomtry.computeFaceNormals() 上述代码需要注意的点有： 创建面时顶点的顺序，因为顶点顺序决定了某个面是面向摄像机还是背向摄像机。顶点的顺序是逆时针则是面向摄像机，反之则是背向摄像机。 出于性能的考虑，Three.js 认为几何体在整个生命周期都不会更改。若出现更改（如某顶点的位置），则需要告诉 geometry 对象的顶点需要更新 geometry.verticesNeedUpdate = true。更多关于需要主动设置变量来开启更新的事项，可查看官方文档的 How to update things。 声音我们从文档目录中竟然发现有 Audio 音频对象，为什么 Three.js 不是游戏引擎，却带个音频组件呢？原来这个音频也是 3D 的，它会受到摄像机的距离影响： 声源离摄像机的距离决定着声音的大小。 声源在摄像机左右侧的位置分别决定着左右扬声器声音的大小。 我们可以到 官方案例 亲自体验一下 Audio 的效果。 常见的插件在 Three.js 的官方案例中，你几乎都能看到左右上角的两个常驻控件，它们分别是：JavaScript 性能监测器 stats.js 和可视化调参插件 dat.GUI。 stats.jsstats.js 为开发者提供了易用的性能监测功能，它目前支持四种模式： 帧率 每帧的渲染时间 内存占用量 用户自定义 dat.GUIdat.GUI 为开发者提供了可视化调参的面板，对参数调整的操作提供了极大的便利。 关于这两个插件的使用，请查看他们的官方文档或 Three.js 官方案例中的代码。 其他一些东西自适应屏幕（窗口）大小12345678910window.addEventListener('resize', onResize, false)function onResize () &#123; // 设置透视摄像机的长宽比 camera.aspect = window.innerWidth / window.innerHeight // 摄像机的 position 和 target 是自动更新的，而 fov、aspect、near、far 的修改则需要重新计算投影矩阵（projection matrix） camera.updateProjectionMatrix() // 设置渲染器输出的 canvas 的大小 renderer.setSize(window.innerWidth, window.innerHeight)&#125; 阴影阴影是增强三维场景效果的重要因素，但 Three.js 出于性能考虑，默认关闭阴影。下面我们来看看如何开启阴影的。 渲染器启用阴影 1renderer.shadowMap.enabled = true 指定哪个光源能产生阴影 12// 并不是所有类型的光源能产生投影，不能产生投影的光源有：环境光（AmbientLight）、半球光（HemisphereLight）spotLight.castShadow = true 指定哪个物体能投射阴影，哪个物体能接受阴影（在 CSS 中，我们都会认为只有背景接受阴影，毕竟它们都是平面） 123456// 平面和立方体都能接受阴影plane.receiveShadow = truecube.receiveShadow = true// 球体的阴影可以投射到平面和球体上sphere.castShadow = true 更改阴影质量 123456// 更改渲染器的投影类型，默认值是 THREE.PCFShadowMaprenderer.shadowMap.type = THREE.PCFSoftShadowMap// 更改光源的阴影质量，默认值是 512spotLight.shadow.mapSize.width = 1024 spotLight.shadow.mapSize.height = 1024 产生阴影： See the Pen shadow by Jc (@JChehe) on CodePen. 雾化效果雾化效果是指：场景中的物体离摄像机越远就会变得越模糊。 目前，Three.js 提供两种雾化效果：12345678910111213// Fog( hex, near, far )，线性雾化。// near 表示哪里开始应用雾化效果（摄像机为 0）// far 表示哪里的雾化浓度为 1。若某物体在该距离后，则其表现为雾的颜色。当雾的颜色和渲染器的背景色相同时，则表现为消失（实为颜色相同）。scene.fog = new THREE.Fog( 0xffffff, 0.015, 100 )// FogExp2( hex, density )，指数雾化// density 是雾化强度scene.fog = new THREE.FogExp2( 0xffffff, 0.01 )// 雾化效果默认是全局影响的，若某个材质不受雾化效果影响，则可为材质的 fog 属性设置为 false（默认值 true）var material = new THREE.Material(&#123; fog: false&#125;) 查看不同位置的立方体： See the Pen fog by Jc (@JChehe) on CodePen. Low Poly其实，对于前端开发来说，能做到用代码实现就要尽量不用外部加载的图片（纹理）来装饰物体就最好了。对于前面提及的几何体，其实只要发挥我们的创意，就能将不起眼的它们变得有魅力，如 Low Poly。 圣诞树： See the Pen Step Five by Matt Agar (@agar) on CodePen. 更多关于 Low Poly 风格的案例和学习资料： 圣诞树：https://www.august.com.au/blog/animating-scenes-with-webgl-three-js/ 飞行者（The Aviator）小游戏：https://tympanus.net/codrops/2016/04/26/the-aviator-animating-basic-3d-scene-threejs/ Yakudoo’s Codepen：https://codepen.io/Yakudoo/ 渲染器剔除模式（Face culling）CSS3 有一个 backface-visibility 属性，它指定当元素背面朝向用户时，该元素是否可见。因为元素背面的背景颜色是透明的，所以当其可见时，就会显示元素正面的镜像。 而在 Three.js 中，材质默认只应用在正面（THREE.FrontSide），即当你旋转物体（或摄像机）查看物体的背面时，它会因为未被应用材质而变得透明（即效果与 CSS3 backface-visibility: hidden 一样）。因此，当你想让物体正反两面均应用材质，则需要在创建材质时声明 side 属性为 THREE.DoubleSide： 123var material = new THREE.MeshBasicMaterial(&#123; side: THREE.DoubleSide // 其他值：THREE.FrontSide（默认值）、THREE.BackSide&#125;) 当然，为几何体正反两面均应用材质时，会让渲染器做更多工作，从而影响性能。同理，对于 CSS3，若对动画性能有更高的追求，则可以尝试显示地为 transform 动画元素设置其背面不可见 backface-visibility: hidden;，这样也许能提高性能。 可你是否见过或想到过这样的一个应用场景： 3D 看房 当你旋转时，面向用户的墙都会变得透明，从而实现 360 度查看房子内部结构的效果。 剔除外部立方体正面： See the Pen Face culling by Jc (@JChehe) on CodePen. 上述案例会实时剔除外层立方体的正面，从而保证其内部可见。 这里其实涉及到 OpenGL 的 Face culling 的知识点。出于性能的考虑，Three.js 默认开启 Face culling 特性，且将剔除模式设置为 CullFaceBack（默认值），这样就可剔除对于观察者不可见的反面 。 因此，当我们将剔除模式设置为 CullFaceFront（剔除正面） 时，就会发生以上效果。一切看起来都是这么自然。其实仔细想想，就会发现有点不对劲。 假设一个面由正面和反面组成，那现在只剔除正面，那该面的反面不就显示出来了？答：其实正面还是反面是相对于观察者的，而不是说一个面由正面和反面组成。当然你也可以认为一个面是无限扁的，由正反两面组成，但只有面向观察者的一面才可见。 那现在被显示出来的面都是反面（相对于观察者），而这些反面并没有应用材质（side: THREE.BackSide 或 THREE.DoubleSide），那它不应该也是不可见的吗？答：笔者反复试验和查阅资料后，仍然没得出答案，若你知道原因麻烦告诉我哦。 关于 OpenGL 的 Face culling 更多知识，可阅读：《Learn OpenGL》。 粒子化对于粒子化效果，相信大家都不陌生。前段时间的 《腾讯的 UP2017》 就是应用 Three.js 实现粒子化效果的精彩案例。 对于 Three.js，实现粒子效果的方法有两种：THREE.Sprite( material ) 和 THREE.Points( geometry, material )。而且这两者都会一直面向摄像机（无论你旋转摄像机还是设置粒子的 rotation 属性）。 下面基于 THREE.Sprite 实现一个简单的 10 x 10 粒子效果（可拖拽旋转）： See the Pen sprite by Jc (@JChehe) on CodePen. 当粒子数量较小时，一般不会存在性能问题。但随着数量的增长，就会很快遇到性能瓶颈。此时，使用 THREE.Points 更为合适。因为 Three.js 不再需要管理大量 THREE.Sprite 对象，而只需管理一个 THREE.Points 对象。 下面我们用 THREE.Points 实现上一个案例的效果： See the Pen points by Jc (@JChehe) on CodePen. 从上述两个案例可看到，粒子默认形状是正方形。若想改变它的形状，则需要用到纹理。样式化粒子的纹理一般有两种方式：加载外部图片和 Canvas 2D 画布。 Canvas 2D 画布： See the Pen points-canvas by Jc (@JChehe) on CodePen. 加载外部图片： See the Pen points-img by Jc (@JChehe) on CodePen. 上一个案例中，我们加载了两个不同的纹理。由于 THREE.Points 的局限性（一个材质只能对应一种纹理），若想添加多个纹理，则需要创建相应个数的 THREE.Points 实例，而 THREE.Sprite 在此方面显得更灵活一些。 上述粒子效果都是我们手动设置各个粒子的具体位置，若想将特定形状通过粒子效果显示，则可以直接将该几何体（geometry）传入 THREE.Points( geometry, material ) 的第一个参数即可。 See the Pen points-models by Jc (@JChehe) on CodePen. 点击物体鼠标作为 PC 端（移动端中的触摸）的主要交互方式，我们经常会通过它来选择页面上的元素。而对于 Three.js，它没有类似 DOM 的层级关系，并且处于三维环境中，那么我们则需要通过以下方式来判断某对象是否被选中。12345678910111213141516function onDocumentMouseDown(event) &#123; var vector = new THREE.Vector3(( event.clientX / window.innerWidth ) * 2 - 1, -( event.clientY / window.innerHeight ) * 2 + 1, 0.5); vector = vector.unproject(camera); var raycaster = new THREE.Raycaster(camera.position, vector.sub(camera.position).normalize()); var intersects = raycaster.intersectObjects([sphere, cylinder, cube]); if (intersects.length &gt; 0) &#123; console.log(intersects[0]); intersects[0].object.material.transparent = true; intersects[0].object.material.opacity = 0.1; &#125;&#125; 当点击鼠标时，上述代码会发生以下处理： 基于屏幕上的点击位置创建一个 THREE.Vector3 向量。 使用 vector.unproject 方法将屏幕上的点击位置转换成 Three.js 场景中的坐标。换句话说，就是将屏幕坐标转换成三维场景中的坐标。 创建 THREE.Raycaster。使用 THREE.Raycaster 可以向场景中发射光线。在下述案例中，从摄像机的位置（camera.position）向场景中鼠标的点击位置发射光线。 使用 raycaster.intersectObjects 方法来判断指定的对象中哪些被该光线照射到的。 上述最后一步会返回包含了所有被光线照射到的对象信息的数组（根据距离摄像机距离，由短到长排序）。数组的子项的信息包括有： 12345distance: 49.90470face: THREE.Face3faceIndex: 4object: THREE.Meshpoint: THREE.Vector3 点击物体后改变其透明度： See the Pen mouse-select by Jc (@JChehe) on CodePen. 最后最后，乱七八糟地整理了自己最近学 Three.js 的相关知识，其中难免出现一些自己理解不透彻，甚至是错误的观点，希望大家能积极提出来。当然，笔者也会捉紧学习，不断完善文章。希望大家多多关注 凹凸实验室。感谢~👏 参考资料 Three.js 开发指南 WebGL Fundamentals dragon/threejs教程","pubDate":"Mon, 28 Aug 2017 04:00:00 GMT","guid":"https://aotu.io/notes/2017/08/28/getting-started-with-threejs/","category":"Web开发"},{"title":"AT - 前端 UI 组件库","link":"https://aotu.io/notes/2017/08/28/at-ui/","description":"AT-UI 是一款基于 Vue 2.x 的前端 UI 组件库，主要用于快速开发 PC 网站产品。 没错，这是又一款基于 Vue 的前端 UI 组件库，又双叒叕款 UI 库~又双叒叕款轮子~ 但在人从众多类似的轮子中，AT-UI 属于视觉风格比较清新的一款。同时 AT-UI 是凹凸实验室官方出品，带有凹凸品牌风格的一套 UI KIT，旨在解决网站项目开发前期的「UI 库选择恐惧症」。 官网：https://at.aotu.io/项目地址：https://github.com/at-ui/at-ui 特性 基于 Vue 开发组件 基于 npm + webpack + babel 的工作流，支持 ES2015 CSS 样式独立，即使采用不同的框架实现都能保持统一的 UI 风格（详见：AT-UI-Style） 项目背景目前市面上同类型的开源项目已经不少了，Antd, iView, Element 等精品项目也是圈粉大拿，成为许多 Web 开发者做管理端的首选 UI 库。为什么在竞争如此激烈的背景下，我们还要做同类型产品 AT-UI 呢？ 首先作为一个成熟的前端团队，我们需要一套统一的 UI 库，以便于更好的对项目进行维护迭代。其次团队成员在日常开发中，会输出一些自定义的组件（例如甘特图等），如果能快速整合到 UI 库中，便可以快速进行测试迭代。最后，我们既有基于 Vue 的项目，也有基于 React 的项目，为了保证不同框架的项目能共用一套 UI，我们迫切需要一款样式能独立迭代的 UI 库。于是乎，秉承着造轮子，也要造好轮子的心态，开始了 AT-UI 的构建之旅。 愿景我们希望 AT-UI 是一款视觉层面精美，代码层面高质量的 UI 库。同时也希望 AT-UI 能包含尽可能多的组件，能做到不请「外援」。为此，我们会尽可能完善各类型的组件，也非常欢迎组件 PR。 AT-UI 的部分组件借鉴了优秀项目 Antd, Element 和 iView 的实现思路及相关源码，并非闭门造车 安装使用 npm 安装推荐使用 npm 的方式进行开发，享受 node 生态圈和 webpack 工具链带来的便利。通过 npm 安装的模块包，我们可以轻松的使用 import 或者 require 的方式引用 123npm install at-uinpm install at-ui-style 浏览器标签引入可以采用传统的 &lt;script&gt; 和 &lt;link&gt; 标签的方式引入资源，并且全局使用 AT-UI。可以在 UNPKG 上找到最新版本的资源文件，然后在页面中直接引入。 123456&lt;!-- 引入Vue --&gt;&lt;script src=\"//vuejs.org/js/vue.min.js\"&gt;&lt;/script&gt;&lt;!-- 引入样式 --&gt;&lt;link rel=\"stylesheet\" href=\"//unpkg.com/at-ui-style/css/at.min.css\"&gt;&lt;!-- 引入组件库 --&gt;&lt;script src=\"//unpkg.com/at-ui/dist/at.min.js\"&gt;&lt;/script&gt; Demo 示例 更多使用说明，请阅读文档 AT-UI 写在最后秉承万维网的开放精神，以及开源世界的信条，我们接受各种评价和讨论，最终目标是为开源世界贡献我们的一份力，感恩！欢迎各位同学使用 AT-UI，如果你在使用过程中遇到问题，或者有好的建议，欢迎给我们提 Issue 或者 Pull Request","pubDate":"Mon, 28 Aug 2017 04:00:00 GMT","guid":"https://aotu.io/notes/2017/08/28/at-ui/","category":"Web开发"},{"title":"CSS技巧：逐帧动画抖动解决方案","link":"https://aotu.io/notes/2017/08/14/fix-sprite-anim/","description":"笔者所在的前端团队主要从事移动端的H5页面开发，而团队使用的适配方案是: viewport units + rem。具体可以参见凹凸实验室的文章 – 利用视口单位实现适配布局 。 笔者目前（2017.08.12）接触到的移动端适配方案中，「利用视口单位实现适配布局」是最好的方案。不过使用 rem 作为单位会遇到以下两个难点： 微观尺寸（20px左右）定位不准 逐帧动画容易有抖动 第一个难点的通常出现在 icon 绘制过程，可以使用图片或者 svg-icon 解决这个问题，笔者强烈建议使用 svg-icon，具体理由可以参见：「拥抱Web设计新趋势：SVG Sprites实践应用」。 第二个难点笔者举个例子来分析抖动的原因和寻找解决方案。 一个抖动的例子做一个8帧的逐帧动画，每帧的尺寸为：360x540。 1234567891011121314151617.steps_anim &#123; position: absolute; width: 9rem; height: 13.5rem; background: url(//misc.aotu.io/leeenx/sprite/m.png) 0 0 no-repeat; background-size: 45rem 13.5rem; top: 50%; left: 50%; margin: -5.625rem 0 0 -5.625rem; animation: step 1.2s steps(5) infinite; &#125;@keyframes step &#123; 100% &#123; background-position: -45rem; &#125;&#125; 观察在主流（手机）分辨率下的播放情况： iPhone 6(375x667)iPhone 6+(414x736)iPhone 5(320x568)Android(360x640) iPhone 6 (375x667) iPhone 6+ (414x736)iPhone 5 (320x568)Android (360x640) ~function() { var _resize = function() { var w = document.body.clientWidth; if(w < 540) { J_table1.style.display = \"none\"; J_table2.style.display = \"block\"; } else { J_table1.style.display = \"block\"; J_table2.style.display = \"none\"; } } _resize(); window.addEventListener(\"resize\", _resize); }(); 四种分辨率下，可以看到除了 ip6 其它的三种分辨率都发生了抖动。（ip6 不抖动的原因是适配方案是基本于 ip6 的分辨率订制的。） 分析抖动图像由终端（屏幕）显示，而终端则是一个个光点（物理像素）组成的矩阵，换句话说图片也一组光点矩阵。为了方便描述，笔者假设终端上的一个光点代表css中的1px。 以下是一张 9px * 3px 的sprite: 每帧的尺寸为 3px * 3px，逐帧的取位过程如下： 把 sprite 的 background-size 的宽度取一半，那么终端会怎么处理？9 / 2 = 4.5终端的光点都是以自然数的形式出现的，这里需要做取整处理。取整一般是三种方式：round/ceil/floor。假设是 round ，那么 background-size: 5px，sprite 会是以下三种的一个： 情况一 情况二 情况三 理论上，5 / 3 = 1.666...。但实际上光点取整后，三个帧的宽度都不可能等于 1.666...，而是有一个帧的宽度降级为 1px（亏），另外两个宽度升级为 2px（盈），笔者把这个现象称作「盈亏互补」。 再看一下盈亏互补后，逐帧的取位过程： 情况一 情况二 情况三 可以看到由于盈亏互补导致了三个帧的宽度不一致，亏的那一帧在动画中的表示就是抖动。 笔者总结抖动的原因是：sprite在尺寸缩放后，帧与帧之间的盈亏互补现象导致动画抖动 附注：1px 由几个光点表示是由以终端的 dpr 决定 解决方案「盈亏互补」也可以说是「盈亏不一致」，如果尺寸在缩放后「盈亏一致」那么抖动现象可以解决。 解决构想一笔者根据「盈亏一致」设计了「解决构想一」： 根据上图，其实很容易就联想到一个简单的方案：不用雪碧图（即一帧对应一张图片）。这个方案确实是可以解决抖问题，不过笔者并不推荐使用它，因为它有两个负面的东西： KB变大与请求数增多 多余的 animation 代码 这个方案很简单，这里就不赘述了。 解决构想二把逐帧取位与图像缩放拆分成两个独立的过程，就是笔者的「解决构想二」： 实现「构想二」，笔者首先想到的是使用 transform: scale()，于是整理了一个实现方案A： 12345678910111213141516171819202122232425262728293031323334.steps_anim &#123; position: absolute; width: 360px; height: 540px; background: url(//misc.aotu.io/leeenx/sprite/m.png) 0 0 no-repeat; background-size: 1800px 540px; top: 50%; left: 50%; transform-origin: left top; margin: -5.625rem 0 0 -5.625rem; transform: scale(.5); animation: step 1.2s steps(5) infinite;&#125;@keyframes step &#123; 100% &#123; background-position: -1800px; &#125;&#125;/* 写断点 */@media screen and (width: 320px) &#123; .steps_anim &#123; transform: scale(0.4266666667); &#125;&#125;@media screen and (width: 360px) &#123; .steps_anim &#123; transform: scale(0.48); &#125;&#125;@media screen and (width: 414px) &#123; .steps_anim &#123; transform: scale(0.552); &#125;&#125; 这个实现方案A存在明显的缺陷：scale 的值需要写很多断点代码。于是笔者结全一段 js 代码来改善这个实现方案B： css:1234567891011121314151617.steps_anim &#123; position: absolute; width: 360px; height: 540px; background: url(\"//misc.aotu.io/leeenx/sprite/m.png\") 0 0 no-repeat; background-size: 1800 540px; top: 50%; left: 50%; transform-origin: left top; margin: -5.625rem 0 0 -5.625rem; animation: step 1.2s steps(5) infinite;&#125;@keyframes step &#123; 100% &#123; background-position: -1800px; &#125;&#125; javascript:123456789// 以下代码放到 &lt;head&gt;&lt;/head&gt; 中&lt;script&gt;document.write(\"&lt;style id='scaleStyleSheet'&gt;.steps_anim &#123;scale(.5); &#125;&lt;/style&gt;\"); function doResize() &#123; scaleStyleSheet.innerHTML = \".steps_anim &#123;-webkit-transform: scale(\" + (document.documentElement.clientWidth / 750) + \")&#125;\"; &#125;window.onresize = doResize; doResize(); &lt;/script&gt; 通过改善后的方案 CSS 的断点没了，感觉是不错了，不过笔者觉得这个方案不是个纯粹的构建方案。 我们知道 &lt;img&gt; 是可以根据指定的尺寸自适应缩放尺寸的，如果逐帧动画也能与 &lt;img&gt; 自适应缩放，那就可以从纯构建角度实现「构想二」。 SVG刚好可以解决难题！！！SVG 的表现与 &lt;img&gt; 类似同时可以做动画。以下是笔者的实现方案C。 html:123&lt;svg viewBox=\"0, 0, 360, 540\" class=\"steps_anim\"&gt; &lt;image xlink:href=\"//misc.aotu.io/leeenx/sprite/m.png\" width=\"1800\" height=\"540\" /&gt;&lt;/svg&gt; css:1234567891011121314151617.steps_anim &#123; position: absolute; width: 9rem; height: 13.5rem; top: 50%; left: 50%; margin: -5.625rem 0 0 -5.625rem; image &#123; animation: step 1.2s steps(5) infinite; &#125;&#125;@keyframes step &#123; 100% &#123; transform: translate3d(-1800px, 0, 0); &#125;&#125; 方案C的改良实现方案C很好地解决了方案A和方案B的缺陷，不过方案C也有它的问题：不利于自动化工具去处理图片。 自动化工具一般是怎么处理图片的？自动化工具一般是扫描 CSS 文件找出所有的 url(...) 语句，然后再处理这些语句指向的图片文件。 如果 &lt;image&gt; 可以改用 CSS 的 background-image 就可以解决这个问题，不过 SVG 不支持 CSS 的 background-image。但是，SVG有一个扩展标签：foreignObject，它允许向 &lt;svg&gt;&lt;/svg&gt; 插入 html 代码。在使用它前，先看一下它的兼容情况： iOS 与 Android 4.3 一片草绿兼容情况算是良好，笔者实机测试腾讯 X5 内核的浏览器兼容仍旧良好。以下是改良后的方案。 html:12345&lt;svg viewBox=\"0, 0, 360, 540\" class=\"steps_anim\"&gt; &lt;foreignObject class=\"html\" width=\"360\" height=\"540\"&gt; &lt;div class=\"img\"&gt;&lt;/div&gt; &lt;/foreignObject&gt;&lt;/svg&gt; css:12345678910111213141516171819202122232425.steps_anim &#123; position: absolute; width: 9rem; height: 13.5rem; top: 50%; left: 50%; margin: -5.625rem 0 0 -5.625rem; &#125;.html &#123; width: 360px; height: 540px; &#125;.img &#123; width: 1800px; height: 540px; background: url(//misc.aotu.io/leeenx/sprite/m.png) 0 0 no-repeat; background-size: 1800px 540px; animation: step 1.2s steps(5) infinite; &#125;@keyframes step &#123; 100% &#123; background-position: -1800px 0; &#125;&#125; 改良后的方案DEMO: http://jdc.jd.com/fd/promote/leeenx/201708/svg-sprite.html 结语感谢阅读完本文章的读者。本文是笔者的个人观点，希望能帮助到有相关问题的朋友，如果本文有不妥之处请不吝赐教。 参考资料：https://stackoverflow.com/questions/9946604/insert-html-code-inside-svg-text-elementhttps://www.w3.org/TR/SVG/extend.htmlhttps://developer.mozilla.org/en-US/docs/Web/SVG/Element/foreignObject","pubDate":"Mon, 14 Aug 2017 13:09:53 GMT","guid":"https://aotu.io/notes/2017/08/14/fix-sprite-anim/","category":"Web开发"},{"title":"这里有你对 Web 游戏的疑问吗？","link":"https://aotu.io/notes/2017/07/23/some-doubts-about-web-games/","description":"本文记录了笔者对 Web 游戏的一些疑问，也许你也恰巧曾经遇到过。 回顾 Flash习大大说道：“不忘历史才能开辟未来，善于继承才能善于创新”。对于新生一代（如 00 后和我🙄 ），由于 Web 新标准的快速推进，有些旧事物也许未接触就已经被新事物取代了。如曾经如日中天的 Flash，现在被 HTML5 逐渐蚕食。 由于我未曾学习过 Flash 编程，所以通过查阅资料发现了一个网站——Waste Creative 公司的《Flash vs HTML5》，它对 Flash 与 HTML5 作出了比较（具体数据也许已过时，但整体趋势不变）。 Flash HTML5 Canvas 运行平台 桌面端 桌面端、移动端 桌面端浏览器支持率 99% 82% 3D 硬件加速支持率 Flash Player 11（stage3D）81% WebGL 53% 文件&amp;资源目录 可编译的 SWFs 意味着 Flash 可作为单个文件共享和重新托管（re-hosted）。这对于 Flash 游戏非常重要。 HTML5 的本质意味着它的基础资源会作为独立的文件加载。因此，HTML5 的托管需要更谨慎。 可视化创作 Flash IDE 对于设计师和新开发者来说是非常友好的，它拥有一个庞大的用户群体和社区。 相较于前者，HTML5 创作工具（Animate CC）目前还处于起步阶段，没有明确的“工业标准”。 移动端浏览器 目前的浏览器不再有 Flash 插件，Adobe 已经停止对先前移动端 player 的支持与迭代。 Canvas 几乎已得到所有浏览器的支持，而 WebGL 的支持程度也逐渐提高。 在移动端早就不支持 Flash 的情况下，现在越来越多桌面端现代浏览器默认不启动 Flash 了。在可预见的未来，HTML5 （Canvas 2D 与 WebGL）的支持度会越来越高。 尽管 HTML5 的支持度越来越高，但是对于很多未接触 Flash 开发而直接着手于 HTML5 开发的新人来说，前辈们的经验无疑是非常宝贵的。在 2014 年有将近 30 万的 Flash 开发者，其中 90% 是和游戏相关的，他们对 Web 游戏的开发和理解都胜于任何使用其他 Web 前端技术进行开发游戏的群体。 基于这点，很多 HTML5 游戏引擎在 API 设计等方面都会考虑 Flash 这个开发群体。另外 Adobe Animate CC（前身是 Flash Professinal）在支持 Flash SWF 文件的基础上，加入了对 HTML5 的支持。因此，熟悉 Flash 的设计师/开发者就能通过 Animate CC 进行可视化创作，然后导出基于 Canvas 的游戏/动画。 渲染模式：Canvas 2D 与 WebGL我们常常听到有人说：“3D 场景用 WebGL”。 这句话对于未深入学习相关知识的人来说，会潜移默化地在脑中留下这样的刻板印象：“WebGL 就是 3D，3D 就是 WebGL”。 其实不然，因为我们也能在三维空间里绘制二维物体嘛。因此，我们能看到很多 2D 游戏引擎（如 PixiJS，Egret）会提供两种渲染模式：Canvas 2D 和 WebGL。但由于两者 API 不相同，游戏引擎会对两者进行一定抽象封装，为开发者提供一致的 API。 注：PixiJS 的定位是渲染器。而为了方便描述，在本文中我们暂且称它为游戏引擎。 另外，我们可以看到在支持上述两种渲染模式的游戏引擎中，都会优先启用 WebGL，若不兼容则回退至 Canvas 2D。游戏引擎之所以采取这种策略，目的之一是获取更高的性能。 那为什么 WebGL 的性能比 Canvas 2D 高？ 在回答上述问题前，我们先了解 Canvas 2D 与 WebGL 的基本信息。 我们都知道 &lt;canvas&gt; 元素提供一个了空白区域，让特定的 JavaScript API 进行绘制。其中，绘制 API 取决于用户所指定的绘制上下文，如 Canvas 2D 或 WebGL。 Canvas 2D对于 Chrome，其 Canvas 2D 的底层实现是 Skia 图形库。其实不止于 Chrome，该库还服务于 Chrome OS、 Android、Mozilla Firefox 和 Firefox OS 等众多产品。 通过在 Chrome 地址栏输入 about:gpu 可看到，Canvas 2D 是支持硬件加速的。若未启用，则在地址栏输入 about:flags，然后启用 Accelerated 2D canvas 选项并重启浏览器即可。 1234567891011121314Graphics Feature StatusCanvas: Hardware accelerated ***Flash: Hardware acceleratedFlash Stage3D: Hardware acceleratedFlash Stage3D Baseline profile: Hardware acceleratedCompositing: Hardware acceleratedMultiple Raster Threads: EnabledNative GpuMemoryBuffers: Hardware acceleratedRasterization: Hardware acceleratedVideo Decode: Hardware acceleratedVideo Encode: Hardware acceleratedWebGL: Hardware acceleratedWebGL2: Hardware accelerated WebGL什么是 WebGL（Web Graphics Library）？简而言之，它允许 JavaScript 对图形硬件进行低阶编程。这无疑让 Web 页面能更好地利用显卡的优势，如 3D、着色器和卓越性能。 另外，目前 WebGL 有两个版本，其中 WebGL 1.0 是基于 OpenGL ES 2.0，WebGL 2.0 是基于 OpenGL ES 3.0。 GPU 是如何渲染 2D 图像的？在了解了 Canvas 2D 和 WebGL 的基本信息后，我们再看看 GPU 是如何渲染 2D 图像的。 首先，我们先介绍渲染处理，以便你了解测试中发生了什么。尽管有点简化，但它能让你有一个基本的认识。要在低阶渲染器（如 WebGL 和 DirectX）中绘制 2D 图像，首先需要一个能包围该图像的四边形。因此，我们需要提供该四边形每个角的坐标（x, y）。这里的每个角都被称为顶点（vertex），如下图的红点所示： 包围着图像的四边形 为了高效地绘制大量的 2D 图像，我们需要有一个能装载每个图像所有顶点的列表。该列表存储在顶点缓冲区，显卡会进行读取绘制。下图中有 5 个海盗公主，有的旋转，有的缩放，共有 20 个顶点。 多个图像时的顶点 显卡是非常先进的技术，它已被庞大的 3D 游戏行业推动多年。现在它的运算速度非常快，渲染 2D 图像的速度更是快得难以形容。因为它的渲染速度甚至比你告诉它渲染哪张图更快。换句话说，计算每个顶点的位置并将其发送到显卡的这个过程可能需要 2 微秒，但显卡完成其工作只需 1 微秒，然后空闲地等待下一个指令。 由此可看出，2D 游戏的性能主要受限于顶点缓冲区的填充速度。所以这里的问题是：计算顶点的位置和将其填充到缓冲区的速度能有多快？ 下面我们将分别对 Canvas 2D 和 WebGL 进行测试。 性能测试为了测试两个渲染器的性能，我们编写了一个标准测试。首先，我们有一个蓝色正方形图像，然后在其基础上绘制足够多的图像，直至让帧率降至 30FPS。这样做是为了最大限度地减少每帧中不必要的计算量，确保我们能得出顶点的填充速度。另外，图像是具有透明度的，因此我们能看到它们不断地堆叠起来，如下图： 测试示例图 我们可在各个浏览器上进行测试，以查看它们的实际渲染速度： Canvas 2D 性能测试链接&gt;&gt; WebGL 性能测试链接&gt;&gt;（前提是要支持/开启 WebGL，否则会回退至 Canvas 2D） 在 Early 2013 MacBook Pro（系统为 macOS 10.12.5，硬件配置为 i7 2.4GHz 处理器、8G 1600 MHz DDR3 内存、GT 650M 显卡）上测试可得出以下数据： 注：对于 Windows，可能还需要修改独显对测试浏览器的支持（默认可能是集显）。 Chrome 59.0.3071.115（正式版本）（64 位）测试数据如下： Chrome Canvas 2D——分数为 2415 Chrome WebGL——分数为 13711 Safari 10.1.1（12603.2.4）测试数据如下： Safari Canvas 2D——分数 7481 Safari WebGL——分数 52061 Firfox 54.0.1（64位） 测试数据如下： Firfox Canvas 2D——分数 5992 Firfox WebGL——分数 66291 由上述数据可得：3 款浏览器的 WebGL 性能都优于 Canvas 2D，Chrome 是 5.6 倍、Safari 是 6.95 倍、Firfox 是 11 倍。而且由分数可看出：Safari 和 Firfox 无论是 Canvas 2D 还是 WebGL 都远强于 Chrome。 为何 WebGL 普遍比 Canvas 2D 性能要高呢？ 对于 Canvas 2D，其 API 相对于 WebGL 更高阶。即它实际并没有直接发送顶点信息到顶点缓冲区，而只是描述了在某个位置上绘制一个 2D 图像，然后再让浏览器计算出具体的顶点信息。 对于 WebGL，它直接给出所有对象的顶点信息。这意味着无需再进行任何计算来确定顶点的信息。这样就可以消除浏览器对顶点处理的开销，从而直接复制到顶点缓冲区。另外，从上面我们的实际测试结果可知，WebGL 的性能提升效果是非常明显的。当然，上述只是简单的测试，实际应用中还是需要考虑实际情况。 综上所述，影响两者性能的因素有很多，如操作系统、硬件、浏览器的底层实现与优化和项目代码质量等。在实际测试中，现代浏览器的 WebGL 性能在整体上优于 Canvas 2D。 也许有人认为：性能够用就好，再高也就是过剩。其实不然，因为除了保证画面流畅外，性能高还有以下好处： 运行流畅且稳定（不会因其他因素干扰而掉帧）。 游戏开发商能拥有更多空间去增加更多功能和提高画面质量。 运行效率更高，能耗更低（电池使用量、发热量）。 游戏为什么要 60FPS，而电影 24FPS 就行一般来说，要达到流畅的体验，电影需要 24FPS，而游戏却要 60FPS。 概括来说，造成两者差异的主要原因有： 两者图像生成原理不同 电影的 FPS 是稳定的，而游戏则是不稳定 更详细的解答请看以下两个链接（此刻，我不生产内容，只是内容的搬运工）： 为什么游戏帧数一般要到 60 帧每秒才流畅，而过去的大部分电影帧数只有 24 帧每秒却没有不流畅感？ 為什麼電影 24 格就行，但遊戲卻要 60 格？ 最后其实原来文章的大纲不止于以上几点（还有 TypeScript、WebAssembly、脏矩形、骨骼动画等），但由于笔者深知自己能力和经验上的不足，所以把模棱两可或不确定的点都取消了。但笔者会在后续的学习中不断完善，甚至增加新的知识点。所以这是一篇不定时更新的博文，请持续关注 凹凸实验室。 看了以上几个心中疑问后，是否觉得离『游戏入门』的门近了一点呢？ 最后，希望大家能在评论区提出更多关于 Web 游戏的疑问，说不定可以收录至本文哦👏。 参考资料： HTML5 游戏引擎深度评测 如何看待 HTML5 开源游戏引擎 Egret，HTML5 游戏开发的前景如何？ HTML5 2D gaming performance analysis","pubDate":"Sun, 23 Jul 2017 04:00:00 GMT","guid":"https://aotu.io/notes/2017/07/23/some-doubts-about-web-games/","category":"Web开发"},{"title":"一篇文章带你快速入门 CreateJS","link":"https://aotu.io/notes/2017/07/19/createjs/","description":"CreateJS 简介 官网：http://www.createjs.cc/ CreateJS 中包含以下四个部分： EaselJS：用于 Sprites 、动画、向量和位图的绘制 TweenJS：用于做动画效果 SoundJS：音频播放引擎 PreloadJS：网站资源预加载 这四个部分都可以单独的引用，可选可不选。 一. 预加载 PreloadJS CreateJS 的 PreloadJS 非常的实用，实现起来也比较简短，如下： 1234567891011//放置静态资源的数组var manifest = [ &#123;src: './images/car_prop2_tyre@2x.png', id: 'tyre'&#125;];var queue = new createjs.LoadQueue();queue.on('complete', handleComplete, this);queue.loadManifest(manifest);//资源加载成功后,进行处理function handleComplete() &#123; var tyre = queue.getResult('tyre'); //获取加载资源&#125; Image 跨域小坑： 有些时候跨域的图片可以成功地使用 Canvas 渲染出来，但是到需要对图片进行某些处理的时候，浏览器就会报错。 “被污染的” Canvas ? 尽管没有 CORS 授权也可以在 Canvas 中使用图像, 但这样做就会污染画布。 只要 Canvas 被污染, 就不能再从画布中提取数据, 也就是说不能再调用 toDataURL() 和 getImageData() 等方法, 否则会抛出安全错误 (security error) 。 解决图片跨域有2种解决方法： 图片所在的服务器设置 Access-Control-Allow-Origin “*” 响应头 手动将 IMG 的 url 转换成当前域名的 url ，详细处理方法 在服务器不支持图片跨域的情况下，我们自己手动将图片转换成同域是比较麻烦的，因此，使用 CreateJS 的 PreloadJS ,将最后一个参数设置为 Anonymous 即可。 12345var queue = new createjs.LoadQueue(false,'','Anonymous'); //LoadQueue ( [preferXHR=true] [basePath=\"\"] [crossOrigin=\"\"] )第一个参数为true，代表通过xhr形式加载.basePath 在加载资源时的，会把basePath加载url前面。这样加载同一个目录下的文件时，可以方便一点。 但是如果url是以协议（如”http://”）或者”../”这样路径开头时，不会添加basePath。crossOrigin 设置为Anonymous的时候，则表示允许跨域 二. EaselJS 的常用 API 画图片用 (Bitmap) 画图形，比如矩形，圆形等用 (Shape) 【类似于改变坐标x，y，增加阴影 Shadow ，透明度 Alpha ，缩小放大 ScaleX/ScaleY 都可以做到】 画文字，用 (Text) 还有容器 Container 的概念，容器可以包含多个显示对象 三. EaselJS 绘图的大致流程 大致流程：创建显示对象→设置一些参数→调用方法绘制→添加到舞台→ update() ，代码如下：1234567891011var canvas = document.querySelector('#canvas');//创建舞台var stage = new createjs.Stage(canvas);//创建一个Shape对象，此处也可以创建文字Text,创建图片Bitmapvar rect = new createjs.Shape();//用画笔设置颜色，调用方法画矩形，矩形参数：x,y,w,hrect.graphics.beginFill(\"#f00\").drawRect(0, 0, 100, 100);//添加到舞台stage.addChild(rect);//刷新舞台stage.update(); graphics 可以设置一些样式，线条宽度，颜色等等，也可以调用一些方法绘制图形，比如矩形 drawRect ，圆形 drawCircle 等等，具体可以自己查看 API。注意：以上的步骤每一步都要有，否则页面不会有绘制的物体。 四. Tick 事件对于有频繁发生改变的物体，如果在每一处变化都刷新舞台的话，代码会比较冗余，因此我们可以写一个 Tick 事件，在每一次 Tick 的时候 update 舞台。123456789createjs.Ticker.addEventListener(“tick”, tick);function tick(e) &#123; if (e.paused !== 1) &#123; //处理 stage.update(); //刷新舞台 &#125;else &#123;&#125;&#125;createjs.Ticker.paused = 1; //在函数任何地方调用这个，则会暂停tick里面的处理createjs.Ticker.paused = 0; //恢复游戏 在暂停的时候，页面仍会触发 Tick 事件，如果需要完全移除 Tick 事件，则使用 1createjs.Ticker.removeEventListener(\"tick\", tick); 五. Ticker 帧频率上面说的 Tick 事件，每一次触发的频率是可以修改的。理想的帧频率是 60FPS。1createjs.Ticker.setFPS(60); 六. CreateJS 的渲染模式CreateJs 提供了两种渲染模式，一种是用 setTimeout ，一种是用 requestAnimationFrame ，默认是 setTimeout ，默认的帧数是 20 ，一般的话还没有什么区别，但是如果动画多的话，设置成 requestAnimationFrame 模式的话，就会感觉到动画如丝般的流畅。1createjs.Ticker.timingMode = createjs.Ticker.RAF; 使用这种模式，则会忽略 Ticker 的帧频 FPS 。 七. CreateJS 事件EaselJS 事件默认是不支持 Touch 设备的，需要以下代码才支持：1createjs.Touch.enable(stage); 对于 Bitmap， Shape 等对象，都可以直接使用 addEventListener 进行事件监听。12bitmap = new createjs.Bitmap('');bitmap.addEventListener（‘click’，handle）; 八. 优化对所绘制物体的控制能力 控制多个显示对象的层级关系 Stage ， Container 对象有个 Children 属性代表子元素，是一个数组，里面的元素层级像下标一样从 0 开始，简单来说就是后面的覆盖前面的（类似于z-index）,后 addChild 的对象则在数组的后面。我们也可以动态改变 Children 的层叠效果。1obj.parent.setChildIndex(obj, n); //n为设置的层级 利用容器 Container 它可以包含 Text 、 Bitmap 、 Shape 、 Sprite 等其他的 EaselJS 元素，包含在一个 Container 中方便统一管理。比如一辆汽车由汽车本身，气泡提示，加速效果，减速效果组成，我们可以将这几个部分放在同一个 Container 中，统一移动。使用方法也比较简单：1234var contain = new createjs.Container();contain.addChild(bgImg);contain.addChild(bitmap);stage.addChild(contain); 我们在后期会频繁对这个 Container 里面的元素进行操作，比如展示加速效果，取消展示减速效果。那我们可以给这些元素设置name属性，之后可以直接使用 getChildByName 获取到该对象。123bitmap.name = ‘quick’; //设置name值quick = this.stage.getChildByName(“quick”); //使用name值方便获取到该对象quick.visible = true; //显示该效果 九. 绘制图像并对图像进行操作 绘制图片123var bg = new createjs.Bitmap(\"./background.png\");stage.addChild(bg);stage.update(); 按照上面的 EaselJS 的正常的绘制流程来说，上面这段代码应该可以正常显示。但是，只是有些情况下可以正常显示的，这个图像资源需要确定加载成功后才可以 new ，否则不会有图像在画布上，如果有做资源预加载，可以直接使用上面的代码，如果没有，则需要在 Image 加载完成 Onload 之后才进行绘制。1234567var img = new Image();img.src = './img/linkgame_pass@2x.png';img.onload = function () &#123; var bg = new createjs.Bitmap(\"./background.png\"); stage.addChild(bg); stage.update();&#125; 仅仅绘制图片是不够的， CreateJS 提供了几种处理图片的方法： 给图片增加遮罩层使用 mask 属性，可以只显示图片和 shape 相交的区域12345678910111213stage = new createjs.Stage(\"gameView\");bg = new createjs.Bitmap(\"./img/linkgame_pass@2x.png\");bg.x = 10;bg.y = 10;//遮罩图形shape = new createjs.Shape();shape.graphics.beginFill(\"#000\").drawCircle(0, 0, 100);shape.x = 200;shape.y = 100;bg.mask = shape; //给图片bg添加遮罩stage.addChild(shape);stage.addChild(bg);stage.update(); 常用应用场景：用来剪裁图片，比如显示圆形的图片等 给图片增加滤镜效果12var blur = new createjs.BlurFilter(5,5,1);bg.filters = [blur]; 我们发现，图片还是没有变模糊，原因是图片添加了 Filter 后 Stage 立即刷新， Filter 只能保持一帧的效果，第二帧 Filter 则失效了。而使用图片的 cache() 方法后，可以使得无论舞台怎么刷新，都可以保持住 Filter 的效果，添加 cache 还有很多作用，可以提高 FPS ，缓存等1bg.cache(0,0,bg.image.width,bg.image.height); 使用 Rectangle 剪裁图片使用 EaselJS 内置的 Rectangle 对象来创建一个选取框，显示图片的某各部分。12345678stage = new createjs.Stage(\"gameView\");bg = new createjs.Bitmap(\"./img/linkgame_pass@2x.png\");bg.x = 10;bg.y = 10;var rect = new createjs.Rectangle(0, 0, 121, 171);bg.sourceRect = rect;stage.addChild(bg);stage.update(e); 适用场景：拼图小游戏，剪裁图片…… 具体的使用方法我们都知道啦，接下来用一个小 Demo 练练手 – 实现一个无缝连接的背景图，模拟汽车加速的状态 1234567891011121314151617181920212223242526272829this.backdrop = new createjs.Bitmap(bg);this.backdrop.x = 0;this.backdrop.y = 0;this.stage.addChild(that.backdrop);this.w = bg.width;this.h = bg.height;//创建一个背景副本，无缝连接var copyy = -bg.height;this.copy = new createjs.Bitmap(bg);this.copy.x = 0;this.copy.y = copyy; //在画布上 y 轴的坐标为负的背景图长//使用 CreateJS 的 Tick 函数，逐帧刷新舞台createjs.Ticker.addEventListener(\"tick\", tick);function tick(e) &#123; if (e.paused !== 1) &#123; //舞台逐帧逻辑处理函数 that.backdrop.y = that.speed + that.backdrop.y; that.copy.y = that.speed + that.copy.y; if (that.copy.y &gt; -40) &#123; that.backdrop.y = that.copy.y + copyy; &#125; if (that.copy.y &gt; -copyy - 100) &#123; that.copy.y = copyy + that.backdrop.y; &#125; &#125; that.stage.update(e);&#125; demo体验链接： http://jdc.jd.com/fd/h5/peidan/demo/car.html 总结整篇文章介绍了下面几个部分 详细介绍了 CreateJS 的常用 API CreateJS 的一些常见 bug 及解决方法 CreateJS 实现小 Demo 参考： https://github.com/pfan123/code-snippet/issues/10 如何使用 CreateJS 来编写HTML5游戏（一）EaselJS简介 如何使用 CreateJS 来编写HTML5游戏（二）使用EaselJS处理图片 如何使用 CreateJS 来编写HTML5游戏（三）使用EaselJS中的制作Sprite类制作 如何使用 CreateJS 来编写HTML5游戏（四）TweenJS和Tick动画 如何使用 CreateJS 来编写HTML5游戏（五）PreloadJS和SoundJS 如何使用 CreateJS 来编写HTML5游戏（六）完成一个简单的打飞机游戏（上） 如何使用 CreateJS 来编写HTML5游戏（七）完成一个简单的打飞机游戏（下）","pubDate":"Wed, 19 Jul 2017 08:25:35 GMT","guid":"https://aotu.io/notes/2017/07/19/createjs/","category":"移动开发"},{"title":"Vue 探索与实践","link":"https://aotu.io/notes/2017/07/17/The-Exploration-and-Practice-of-Vue/","description":"本文主要讲了实际业务在结合 vue 开发的过程中的探索与实践。","pubDate":"Mon, 17 Jul 2017 07:04:31 GMT","guid":"https://aotu.io/notes/2017/07/17/The-Exploration-and-Practice-of-Vue/","category":"项目总结"}]}